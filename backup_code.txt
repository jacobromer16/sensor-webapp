
_layout.tsx code

import { Tabs } from 'expo-router';
import React from 'react';
import { Platform } from 'react-native';

import { HapticTab } from '@/components/HapticTab';
import { IconSymbol } from '@/components/ui/IconSymbol';
import TabBarBackground from '@/components/ui/TabBarBackground';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function TabLayout() {
  const colorScheme = useColorScheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors[colorScheme ?? 'light'].tint,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: Platform.select({
          ios: {
            // Use a transparent background on iOS to show the blur effect
            position: 'absolute',
          },
          default: {},
        }),
      }}>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="house.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="explore"
        options={{
          title: 'Explore',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="paperplane.fill" color={color} />,
        }}
      />
    </Tabs>
  );
}

explore.tsx code

import { Image } from 'expo-image';
import { Platform, StyleSheet } from 'react-native';

import { Collapsible } from '@/components/Collapsible';
import { ExternalLink } from '@/components/ExternalLink';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';

export default function TabTwoScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#D0D0D0', dark: '#353636' }}
      headerImage={
        <IconSymbol
          size={310}
          color="#808080"
          name="chevron.left.forwardslash.chevron.right"
          style={styles.headerImage}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Explore</ThemedText>
      </ThemedView>
      <ThemedText>This app includes example code to help you get started.</ThemedText>
      <Collapsible title="File-based routing">
        <ThemedText>
          This app has two screens:{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/explore.tsx</ThemedText>
        </ThemedText>
        <ThemedText>
          The layout file in <ThemedText type="defaultSemiBold">app/(tabs)/_layout.tsx</ThemedText>{' '}
          sets up the tab navigator.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/router/introduction">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Android, iOS, and web support">
        <ThemedText>
          You can open this project on Android, iOS, and the web. To open the web version, press{' '}
          <ThemedText type="defaultSemiBold">w</ThemedText> in the terminal running this project.
        </ThemedText>
      </Collapsible>
      <Collapsible title="Images">
        <ThemedText>
          For static images, you can use the <ThemedText type="defaultSemiBold">@2x</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">@3x</ThemedText> suffixes to provide files for
          different screen densities
        </ThemedText>
        <Image source={require('@/assets/images/react-logo.png')} style={{ alignSelf: 'center' }} />
        <ExternalLink href="https://reactnative.dev/docs/images">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Custom fonts">
        <ThemedText>
          Open <ThemedText type="defaultSemiBold">app/_layout.tsx</ThemedText> to see how to load{' '}
          <ThemedText style={{ fontFamily: 'SpaceMono' }}>
            custom fonts such as this one.
          </ThemedText>
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/versions/latest/sdk/font">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Light and dark mode components">
        <ThemedText>
          This template has light and dark mode support. The{' '}
          <ThemedText type="defaultSemiBold">useColorScheme()</ThemedText> hook lets you inspect
          what the user&apos;s current color scheme is, and so you can adjust UI colors accordingly.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/develop/user-interface/color-themes/">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Animations">
        <ThemedText>
          This template includes an example of an animated component. The{' '}
          <ThemedText type="defaultSemiBold">components/HelloWave.tsx</ThemedText> component uses
          the powerful <ThemedText type="defaultSemiBold">react-native-reanimated</ThemedText>{' '}
          library to create a waving hand animation.
        </ThemedText>
        {Platform.select({
          ios: (
            <ThemedText>
              The <ThemedText type="defaultSemiBold">components/ParallaxScrollView.tsx</ThemedText>{' '}
              component provides a parallax effect for the header image.
            </ThemedText>
          ),
        })}
      </Collapsible>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  headerImage: {
    color: '#808080',
    bottom: -90,
    left: -35,
    position: 'absolute',
  },
  titleContainer: {
    flexDirection: 'row',
    gap: 8,
  },
});


index.tsx code

import React from 'react';
import { View, Text, StyleSheet, Button, Alert } from 'react-native';

export default function HomeScreen() {
  const handleConnect = () => {
    // Placeholder for future BLE logic
    Alert.alert('Connect button pressed');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <Text style={styles.subtitle}>Bluetooth Device Connection</Text>

      <View style={styles.buttonContainer}>
        <Button title="Connect to Device" onPress={handleConnect} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 100,
    paddingHorizontal: 24,
    backgroundColor: '#f5f9ff',
    alignItems: 'center',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  subtitle: {
    fontSize: 18,
    marginBottom: 24,
    color: '#555',
  },
  buttonContainer: {
    width: '100%',
    maxWidth: 300,
  },
});

full code backup progress working charting


import {
  CategoryScale,
  Chart as ChartJS,
  LinearScale,
  LineElement,
  PointElement,
} from 'chart.js';
import React, { useEffect, useState } from 'react';
import { Line } from 'react-chartjs-2';
import { StyleSheet, Text, View } from 'react-native';

ChartJS.register(LineElement, CategoryScale, LinearScale, PointElement);

export default function LiveChartScreen() {
  // 35-item array, initialized to all 0s
  const [sensorData, setSensorData] = useState<number[]>(Array(35).fill(0));
  const [chartData, setChartData] = useState({
    labels: Array(20).fill(''),
    datasets: [
      {
        label: 'Sensor 1 (Index 0)',
        data: [],
        borderColor: 'blue',
        fill: false,
      },
    ],
  });

  // Simulate sensor data update: toggle index 0 between 0 and 1 every second
  useEffect(() => {
    const interval = setInterval(() => {
      setSensorData(prev => {
        const newVal = prev[0] === 0 ? 1 : 0;
        const updated = [...prev];
        updated[0] = newVal;
        return updated;
      });
    }, 1000);
    return () => clearInterval(interval);
  }, []);

  // Update chart data when sensorData[0] changes
  useEffect(() => {
    setChartData(prev => {
      const updatedData = [...prev.datasets[0].data];
      if (updatedData.length >= 20) updatedData.shift();
      updatedData.push(sensorData[0]);
      return {
        ...prev,
        datasets: [{ ...prev.datasets[0], data: updatedData }],
      };
    });
  }, [sensorData]);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Live Sensor Data Chart</Text>
      <Line data={chartData} options={{ responsive: true, maintainAspectRatio: false }} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 100,
    paddingHorizontal: 20,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
});


working three charts code

import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import { Dimensions, ScrollView, StyleSheet, Text, View } from 'react-native';

ChartJS.register(
  LineElement,
  CategoryScale,
  LinearScale,
  PointElement,
  Title,
  Tooltip,
  Legend
);

const screenWidth = Dimensions.get('window').width;
const chartWidth = screenWidth / 2.2;
const chartHeight = 340;

const staticColors = [
  '#28a745', // col1 - green
  '#007bff', // col2 - blue
  '#ffc107', // col3 - yellow
  '#dc3545', // col4 - red
  '#17a2b8', // col5 - cyan
  '#6f42c1', // col6 - purple
  '#fd7e14', // col7 - orange
];

const ChartBlock = ({ title, series }: { title: string; series: { label: string; data: number[] }[] }) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: true,
          text: 'Index',
        },
      },
      y: {
        title: {
          display: true,
          text: 'Value',
        },
        beginAtZero: true,
        max: 100,
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line data={chartData} options={options} width={screenWidth / 2 - 30} height={chartHeight} />
    </View>
  );
};

export default function HomeScreen() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    const generateInitialData = () => {
      const data: { [key: string]: number[] } = {};
      for (let i = 0; i < 35; i++) {
        const key = `col${i}`;
        data[key] = Array.from({ length: 170 }, () => Math.floor(Math.random() * 100));
      }
      return data;
    };
    setSensorData(generateInitialData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      const updatedData: { [key: string]: number[] } = {};
      for (let i = 0; i < 35; i++) {
        const key = `col${i}`;
        updatedData[key] = Array.from({ length: 170 }, () => Math.floor(Math.random() * 100));
      }
      setSensorData(updatedData);
    }, 2000);
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Chart: col1, col2, col3"
          series={['col1', 'col2', 'col3'].map((key) => ({ label: key, data: sensorData[key] || [] }))}
        />
        <ChartBlock
          title="Chart: col4, col5, col6"
          series={['col4', 'col5', 'col6'].map((key) => ({ label: key, data: sensorData[key] || [] }))}
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Chart: col7"
          series={[{ label: 'col7', data: sensorData['col7'] || [] }]}
        />
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingTop: 60,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 40,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 20,
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight + 60,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 10,
    color: '#333',
  },
});

working charts with 3 tabs

// App.tsx

import {
  createBottomTabNavigator
} from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

const screenWidth = Dimensions.get('window').width;
const chartHeight = 340;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const ChartBlock = ({ title, series }: { title: string; series: { label: string; data: number[] }[] }) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: true, text: 'Index' },
      },
      y: {
        title: { display: true, text: 'Value' },
        beginAtZero: true,
        max: 100,
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock title={`Chart: ${keys[0]}, ${keys[1]}, ${keys[2]}`} series={getSeries(keys.slice(0, 3))} />
        <ChartBlock title={`Chart: ${keys[3]}, ${keys[4]}, ${keys[5]}`} series={getSeries(keys.slice(3, 6))} />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock title={`Chart: ${keys[6]}`} series={getSeries([keys[6]])} />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    const generateInitialData = () => {
      const data: { [key: string]: number[] } = {};
      for (let i = 0; i < 35; i++) {
        const key = `col${i}`;
        data[key] = Array.from({ length: 170 }, () => Math.floor(Math.random() * 100));
      }
      return data;
    };
    setSensorData(generateInitialData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      const updatedData: { [key: string]: number[] } = {};
      for (let i = 0; i < 35; i++) {
        const key = `col${i}`;
        updatedData[key] = Array.from({ length: 170 }, () => Math.floor(Math.random() * 100));
      }
      setSensorData(updatedData);
    }, 2000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Group 1">
        {() => <SensorTab startIndex={1} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingTop: 60,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 40,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 20,
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight + 60,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 10,
    color: '#333',
  },
});


backup working 5 charts 

import {
  createBottomTabNavigator
} from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  View,
} from 'react-native';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

const screenWidth = Dimensions.get('window').width;
const chartHeight = 340;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const ChartBlock = ({ title, series }: { title: string; series: { label: string; data: number[] }[] }) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: true, text: 'Index' },
      },
      y: {
        title: { display: true, text: 'Value' },
        beginAtZero: true,
        max: 100,
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock title={`Chart: ${keys[0]}, ${keys[1]}, ${keys[2]}`} series={getSeries(keys.slice(0, 3))} />
        <ChartBlock title={`Chart: ${keys[3]}, ${keys[4]}, ${keys[5]}`} series={getSeries(keys.slice(3, 6))} />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock title={`Chart: ${keys[6]}`} series={getSeries([keys[6]])} />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    const generateInitialData = () => {
      const data: { [key: string]: number[] } = {};
      for (let i = 0; i < 35; i++) {
        const key = `col${i}`;
        data[key] = Array.from({ length: 170 }, () => Math.floor(Math.random() * 100));
      }
      return data;
    };
    setSensorData(generateInitialData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      const updatedData: { [key: string]: number[] } = {};
      for (let i = 0; i < 35; i++) {
        const key = `col${i}`;
        updatedData[key] = Array.from({ length: 170 }, () => Math.floor(Math.random() * 100));
      }
      setSensorData(updatedData);
    }, 2000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Group 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingTop: 60,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 40,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 20,
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight + 60,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 10,
    color: '#333',
  },
});


10:46 pm backup code 


import {
  createBottomTabNavigator
} from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  View,
} from 'react-native';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

const screenWidth = Dimensions.get('window').width;
const chartHeight = 340;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const ChartBlock = ({ title, series }: { title: string; series: { label: string; data: number[] }[] }) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,       // removes circles
      tension: 0.4,         // smooths lines
    })),
  };

  const options = {
  responsive: false,
  maintainAspectRatio: false,
  scales: {
    x: {
      title: { display: true, text: 'Index' },
    },
    y: {
      title: { display: true, text: 'Value' },
      min: -100,
      max: 100,
      grid: {
        color: (context: any) => {
          return context.tick.value === 0 ? '#000' : '#ccc'; // Emphasize 0 line
        },
        lineWidth: (context: any) => {
          return context.tick.value === 0 ? 2 : 1;
        },
      },
    },
  },
};


  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock title={`Chart: ${keys[0]}, ${keys[1]}, ${keys[2]}`} series={getSeries(keys.slice(0, 3))} />
        <ChartBlock title={`Chart: ${keys[3]}, ${keys[4]}, ${keys[5]}`} series={getSeries(keys.slice(3, 6))} />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock title={`Chart: ${keys[6]}`} series={getSeries([keys[6]])} />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Generate initial empty (zero) data
  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  // Randomize data for all columns
  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 100)
      );
    }
    setSensorData(updatedData);
  };

  // Set initial zero data
  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  // Randomize every 2 seconds
  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Group 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Group 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingTop: 60,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 40,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: 20,
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight + 60,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 10,
    color: '#333',
  },
});



backup 



import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const layoutPadding = 140;
const chartHeight = screenHeight / 2.5;

const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Color palette for charts
const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

// Legend label map
const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z', col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z',col6: 'Impact', 
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

// Reusable chart block
const ChartBlock = ({
  title,
  series,
}: {
  title: string;
  series: { label: string; data: number[] }[];
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: true, text: 'Index' },
      },
      y: {
        title: { display: true, text: 'Value' },
        min: -100,
        max: 100,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

// One tab view (7 columns → 3 charts)
const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock title="Gyroscope" series={getSeries(keys.slice(0, 3))} />
        <ChartBlock title="Accelerometer" series={getSeries(keys.slice(3, 6))} />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock title="Impact" series={getSeries([keys[6]])} />
      </View>
    </View>
  );
};

// Bottom tab navigator
const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    setSensorData(updatedData);
  };

  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Satellite Board 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

// Styles
const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 60,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 10,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});



backup 


import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8; // Uses more vertical space

const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

// Axis label mapping
const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

// Reusable chart block
const ChartBlock = ({
  title,
  series,
}: {
  title: string;
  series: { label: string; data: number[] }[];
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: true, // ⛔️ No axis title
          text: '',
        },
        ticks: {
          display: true, // ✅ Still shows tick labels (0, 10, 20, ...)
        },
      },
      y: {
        title: { display: true, text: 'Value' },
        min: -100,
        max: 100,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

// Sensor group layout
const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock title="Gyroscope" series={getSeries(keys.slice(0, 3))} />
        <ChartBlock title="Accelerometer" series={getSeries(keys.slice(3, 6))} />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock title="Impact" series={getSeries([keys[6]])} />
      </View>
    </ScrollView>
  );
};

// Tab setup
const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    setSensorData(updatedData);
  };

  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Satellite Board 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

// Styles
const styles = StyleSheet.create({
  container: {
    paddingTop: 30,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 10,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});


backup 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8; // Uses more vertical space

const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

// Axis label mapping
const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

// Reusable chart block
const ChartBlock = ({
  title,
  series,
}: {
  title: string;
  series: { label: string; data: number[] }[];
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: true, // ⛔️ No axis title
          text: '',
        },
        ticks: {
          display: true, // ✅ Still shows tick labels (0, 10, 20, ...)
        },
      },
      y: {
        title: { display: true, text: 'Value' },
        min: -100,
        max: 100,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

// Sensor group layout
const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock title="Gyroscope" series={getSeries(keys.slice(0, 3))} />
        <ChartBlock title="Accelerometer" series={getSeries(keys.slice(3, 6))} />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock title="Impact" series={getSeries([keys[6]])} />
      </View>
    </ScrollView>
  );
};

// Tab setup
const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    setSensorData(updatedData);
  };

  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Satellite Board 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

// Styles
const styles = StyleSheet.create({
  container: {
    paddingTop: 30,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 10,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});


backup 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import { Dimensions, ScrollView, StyleSheet, Text, View } from 'react-native';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

// Chart block with range customization
const ChartBlock = ({
  title,
  series,
  yAxisMin,
  yAxisMax,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: true },
      },
      y: {
        title: { display: true, text: 'Value' },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-100}
          yAxisMax={100}
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-100}
          yAxisMax={100}
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={-1000}
          yAxisMax={1000}
        />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    setSensorData(updatedData);
  };

  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Satellite Board 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

// Styles
const styles = StyleSheet.create({
  container: {
    paddingTop: 30,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 10,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});
backup 12:34 friday morning

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import { Dimensions, ScrollView, StyleSheet, Text, View } from 'react-native';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

// Chart block with individual Y-axis range and hidden X-axis labels
const ChartBlock = ({
  title,
  series,
  yAxisMin,
  yAxisMax,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: false }, // Hide X-axis tick labels
        grid: { display: false },  // Optional: hide vertical grid lines
      },
      y: {
        title: { display: true, text: 'Value' },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-100}
          yAxisMax={100}
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-100}
          yAxisMax={100}
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={-1000}
          yAxisMax={1000}
        />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    setSensorData(updatedData);
  };

  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Satellite Board 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

// Styles
const styles = StyleSheet.create({
  container: {
    paddingTop: 30,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});


backup 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import { Dimensions, ScrollView, StyleSheet, Text, View } from 'react-native';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

// Chart block with customizable Y-axis title
const ChartBlock = ({
  title,
  series,
  yAxisMin,
  yAxisMax,
  yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: false },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    setSensorData(updatedData);
  };

  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <Tab.Navigator>
      <Tab.Screen name="Satellite Board 1">
        {() => <SensorTab startIndex={0} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 2">
        {() => <SensorTab startIndex={7} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 3">
        {() => <SensorTab startIndex={14} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 4">
        {() => <SensorTab startIndex={21} sensorData={sensorData} />}
      </Tab.Screen>
      <Tab.Screen name="Satellite Board 5">
        {() => <SensorTab startIndex={28} sensorData={sensorData} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
}

// Styles
const styles = StyleSheet.create({
  container: {
    paddingTop: 30,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});

backup with chopped BLE Connection

// App.tsx
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import { Dimensions, ScrollView, StyleSheet, Text, View } from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: false },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>({});
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateZeroData = (): { [key: string]: number[] } => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  };

  const randomizeSensorData = () => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    setSensorData(updatedData);
  };

  useEffect(() => {
    setSensorData(generateZeroData());
  }, []);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      randomizeSensorData();
    }, 6000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <>
      <Tab.Navigator>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector />
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingTop: 30,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = () => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);

  const deviceName = 'Dummy Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const eventTriggeredCharacteristic = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let bleServer: BluetoothRemoteGATTServer | null = null;
  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];

  const isWebBLEAvailable = () => !!navigator.bluetooth;

  const handleNotifications = (event: Event) => {
    const target = event.target as BluetoothRemoteGATTCharacteristic;
    console.log('🔔 Notification from:', target.uuid);

    accCharacteristics.forEach(c =>
      c.readValue().then(v => console.log('ACC:', v))
    );
    gyroCharacteristics.forEach(c =>
      c.readValue().then(v => console.log('GYRO:', v))
    );
    impactCharacteristics.forEach(c =>
      c.readValue().then(v => console.log('IMPACT:', v))
    );
  };

  const connectToDevice = async () => {
    if (!isWebBLEAvailable()) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      bleServer = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      const impactService = await bleServer.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await bleServer.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await bleServer.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await bleServer.getPrimaryService(userServiceUUID);
      const userDataCharacteristics = await userService.getCharacteristics();

      const notifyChar = userDataCharacteristics.find(c => c.uuid === eventTriggeredCharacteristic);

      if (notifyChar) {
        await notifyChar.startNotifications();
        notifyChar.addEventListener('characteristicvaluechanged', handleNotifications);
        setStatus('Notifications started');
        console.log('✅ Subscribed to eventTriggeredCharacteristic notifications.');
      } else {
        setStatus('Notification characteristic not found.');
        console.warn('⚠️ Notification characteristic not found.');
      }
    } catch (err) {
      console.error('Connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  return (
    <div style={{ padding: 0, borderTop: '1px solid #ccc', marginTop: 0 }}>
      <h3>BLE Device Connector</h3>
      <button onClick={connectToDevice} disabled={connected}>
        {connected ? 'Connected' : 'Connect to BLE Device'}
      </button>
      <p>Status: {status}</p>
    </div>
  );
};


working BLE integration 

only plots random data upon pair and successful connection 

// App.tsx
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import { Dimensions, ScrollView, StyleSheet, Text, View } from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: false },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (\u00b0/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </ScrollView>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingTop: 30,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';
  const NUM_COLUMNS = 35;
  const DATA_LENGTH = 170;

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'], // fake for now
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      // Start random data updates
      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);

    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <div style={{ padding: 0, borderTop: '1px solid #ccc', marginTop: 0 }}>
      <h3>BLE Device Connector</h3>
      <button onClick={connectToDevice} disabled={connected}>
        {connected ? 'Connected' : 'Connect to BLE Device'}
      </button>
      <p>Status: {status}</p>
    </div>
  );
};

backups 

// App.tsx
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: false },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={{ flex: 1, backgroundColor: '#fff' }}>
      <ScrollView contentContainerStyle={styles.container}>
        <Text style={styles.title}>Sensor Dashboard</Text>
        <View style={styles.topRow}>
          <ChartBlock
            title="Gyroscope"
            series={getSeries(keys.slice(0, 3))}
            yAxisMin={-2000}
            yAxisMax={2000}
            yAxisTitle="Angular Velocity (\u00b0/s)"
          />
          <ChartBlock
            title="Accelerometer"
            series={getSeries(keys.slice(3, 6))}
            yAxisMin={-400}
            yAxisMax={400}
            yAxisTitle="Acceleration (g)"
          />
        </View>
        <View style={styles.bottomRow}>
          <ChartBlock
            title="Impact"
            series={getSeries([keys[6]])}
            yAxisMin={0}
            yAxisMax={2.4}
            yAxisTitle="Impact (V)"
          />
        </View>
      </ScrollView>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flexGrow: 1,
    paddingTop: 30,
    paddingHorizontal: 10,
    paddingBottom: 80, // avoid chart being overlapped
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


working with a bit of Scroll

// App.tsx
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 2.8;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: false },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={{ flex: 1, backgroundColor: '#fff' }}>
      <ScrollView contentContainerStyle={styles.container}>
        <Text style={styles.title}>Sensor Dashboard</Text>
        <View style={styles.topRow}>
          <ChartBlock
            title="Gyroscope"
            series={getSeries(keys.slice(0, 3))}
            yAxisMin={-2000}
            yAxisMax={2000}
            yAxisTitle="Angular Velocity (\u00b0/s)"
          />
          <ChartBlock
            title="Accelerometer"
            series={getSeries(keys.slice(3, 6))}
            yAxisMin={-400}
            yAxisMax={400}
            yAxisTitle="Acceleration (g)"
          />
        </View>
        <View style={styles.bottomRow}>
          <ChartBlock
            title="Impact"
            series={getSeries([keys[6]])}
            yAxisMin={0}
            yAxisMax={2.4}
            yAxisTitle="Impact (V)"
          />
        </View>
      </ScrollView>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flexGrow: 1,
    paddingTop: 30,
    paddingHorizontal: 10,
    paddingBottom: 80, // avoid chart being overlapped
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  chartBlock: {
    width: screenWidth / 2 - 30,
    height: chartHeight,
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};

backup 

// App.tsx
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const chartData = {
    labels: series[0]?.data.map((_, idx) => idx.toString()),
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: false, text: '' },
        ticks: { display: false },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (\u00b0/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


woking everthing now uI changes full integration not yet completed

// App.tsx
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2000;
const SamplingFreqImpact = 2000;
const SamplingFreqAccelero = 2000;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  // Determine which sampling frequency to use
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: true, text: 'Time (ms)' },
        ticks: { display: true },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


backup 


// App.tsx
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2000;
const SamplingFreqImpact = 2000;
const SamplingFreqAccelero = 2000;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  // Determine which sampling frequency to use
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: true, text: 'Time (ms)' },
        ticks: { display: true },
        grid: { display: false },
      },
      y: {
        title: { display: true, text: yAxisTitle },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


backup working

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2000;
const SamplingFreqImpact = 2000;
const SamplingFreqAccelero = 2000;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z',
  col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z',
  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z',
  col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z',
  col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z',
  col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: true,
          text: 'Time (ms)',
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          display: true,
          font: {
            size: 12,
            weight: 'bold',
          },
          maxTicksLimit: 10, // Reduced tick density while showing full range
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle,
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          font: {
            size: 12,
            weight: 'bold',
          },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 20,
          boxHeight: 10,
          usePointStyle: true,
          pointStyle: 'rect',
          font: {
            weight: 'bold',
            size: 14,
          },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};

backup


import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X',  col1: 'Gyro Y',  col2: 'Gyro Z',  col3: 'Accel X',  col4: 'Accel Y',  col5: 'Accel Z',  col6: 'Impact',
  col7: 'Gyro X',  col8: 'Gyro Y',  col9: 'Gyro Z',  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: true,
          text: 'Time (ms)',
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          display: true,
          font: {
            size: 12,
            weight: 'bold',
          },
          maxTicksLimit: 10, // Reduced tick density while showing full range
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle,
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          font: {
            size: 12,
            weight: 'bold',
          },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 20,
          boxHeight: 10,
          usePointStyle: true,
          pointStyle: 'rect',
          font: {
            weight: 'bold',
            size: 14,
          },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};                            // update here with queries for data and then parse it then return it
    for (let i = 0; i < NUM_COLUMNS; i++) {                                         // update here with queries for data and then parse it then return it
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>            // update here with queries for data and then parse it then return it
        Math.floor(Math.random() * 201) - 100                                       // update here with queries for data and then parse it then return it
      );                                                                            // update here with queries for data and then parse it then return it
    }                                                                               // update here with queries for data and then parse it then return it
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } 
    catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X',  col1: 'Gyro Y',  col2: 'Gyro Z',  col3: 'Accel X',  col4: 'Accel Y',  col5: 'Accel Z',  col6: 'Impact',
  col7: 'Gyro X',  col8: 'Gyro Y',  col9: 'Gyro Z',  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: true,
          text: 'Time (ms)',
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          display: true,
          font: {
            size: 12,
            weight: 'bold',
          },
          maxTicksLimit: 10, // Reduced tick density while showing full range
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle,
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          font: {
            size: 12,
            weight: 'bold',
          },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 20,
          boxHeight: 10,
          usePointStyle: true,
          pointStyle: 'rect',
          font: {
            weight: 'bold',
            size: 14,
          },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};                            // update here with queries for data and then parse it then return it
    for (let i = 0; i < NUM_COLUMNS; i++) {                                         // update here with queries for data and then parse it then return it
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>            // update here with queries for data and then parse it then return it
        Math.floor(Math.random() * 201) - 100                                       // update here with queries for data and then parse it then return it
      );                                                                            // update here with queries for data and then parse it then return it
    }                                                                               // update here with queries for data and then parse it then return it
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } 
    catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};

backup 


import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X',  col1: 'Gyro Y',  col2: 'Gyro Z',  col3: 'Accel X',  col4: 'Accel Y',  col5: 'Accel Z',  col6: 'Impact',
  col7: 'Gyro X',  col8: 'Gyro Y',  col9: 'Gyro Z',  col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: true,
          text: 'Time (ms)',
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          display: true,
          font: {
            size: 12,
            weight: 'bold',
          },
          maxTicksLimit: 10, // Reduced tick density while showing full range
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: true,
          text: yAxisTitle,
          font: {
            size: 14,
            weight: 'bold',
          },
        },
        ticks: {
          font: {
            size: 12,
            weight: 'bold',
          },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 20,
          boxHeight: 10,
          usePointStyle: true,
          pointStyle: 'rect',
          font: {
            weight: 'bold',
            size: 14,
          },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={screenWidth / 2 - 30}
        height={chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 0,
    fontWeight: 'bold',
    marginBottom: 0,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};                            // update here with queries for data and then parse it then return it
    for (let i = 0; i < NUM_COLUMNS; i++) {                                         // update here with queries for data and then parse it then return it
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>            // update here with queries for data and then parse it then return it
        Math.floor(Math.random() * 201) - 100                                       // update here with queries for data and then parse it then return it
      );                                                                            // update here with queries for data and then parse it then return it
    }                                                                               // update here with queries for data and then parse it then return it
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } 
    catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};
backup 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z', col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 20,
          boxHeight: 10,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: 14 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={styles.chartBlock}>
      <Text style={styles.subtitle}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.1 : screenWidth / 2 - 30}
        height={compact ? chartHeight / 1.5 : chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const renderChartSet = (startIndex: number) => {
    const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);
    const getSeries = (keys: string[]) =>
      keys.map((key) => ({
        label: key,
        data: sensorData[key] || [],
      }));

    return (
      <View key={startIndex} style={styles.satelliteGroup}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
          compact={true}
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
          compact={true}
        />
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
          compact={true}
        />
      </View>
    );
  };

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>All Satellites Overview</Text>
      <View style={styles.gridWrapper}>
        {[0, 7, 14, 21, 28].map(renderChartSet)}
      </View>
    </View>
  );
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 10,
    backgroundColor: '#fff',
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  satelliteGroup: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
    marginBottom: 10,
  },
  gridWrapper: {
    flex: 1,
    justifyContent: 'space-around',
    alignItems: 'center',
    paddingBottom: 10,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});

//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////

const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Dummy Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};



backup full working code 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useEffect, useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z', col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30}
        height={compact ? chartHeight / 2.2 : chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -400, yMax: 400, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -2000, yMax: 2000, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: 2.4, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
        />
      );
    });
  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const deviceName = 'Real Data';

  const generateRandomSensorData = (): { [key: string]: number[] } => {
    const updatedData: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      updatedData[`col${i}`] = Array.from({ length: DATA_LENGTH }, () =>
        Math.floor(Math.random() * 201) - 100
      );
    }
    return updatedData;
  };

  const connectToDevice = async () => {
    if (!navigator.bluetooth) {
      setStatus('Web Bluetooth not supported in this browser.');
      return;
    }

    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: ['battery_service'],
      });

      await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);
      console.log('✅ BLE connection successful to:', device.name);

      intervalRef.current = setInterval(() => {
        const newData = generateRandomSensorData();
        onSensorData(newData);
      }, 6000);
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z', col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30}
        height={compact ? chartHeight / 2.2 : chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -400, yMax: 400, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -2000, yMax: 2000, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: 2.4, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
        />
      );
    });
  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const sensorMatrixRef = useRef<number[][]>(
    Array.from({ length: 170 }, () => Array(35).fill(null))
  );
  const incompleteChunksRef = useRef<{ [uuid: string]: number[] }>({});

  const deviceName = 'Real Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let userDataCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];

  const connectToDevice = async () => {
    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      const server = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);

      const impactService = await server.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await server.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await server.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await server.getPrimaryService(userServiceUUID);
      userDataCharacteristics = await userService.getCharacteristics();

      subscribeToAllNotifications();
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  const subscribeToAllNotifications = () => {
    const allCharacteristics = [
      ...accCharacteristics,
      ...gyroCharacteristics,
      ...impactCharacteristics,
      ...userDataCharacteristics,
    ];

    allCharacteristics.forEach((char) => {
      char.startNotifications().then(() => {
        char.addEventListener('characteristicvaluechanged', (event) =>
          handleCharacteristicNotification(event.target as BluetoothRemoteGATTCharacteristic)
        );
        console.log(`Notifications started for ${char.uuid}`);
      }).catch((e) => console.log('Notification error:', e));
    });
  };

  const handleCharacteristicNotification = (characteristic: BluetoothRemoteGATTCharacteristic) => {
    const uuid = characteristic.uuid;
    const value = characteristic.value!;
    const chunk = new Uint8Array(value.buffer);

    if (!incompleteChunksRef.current[uuid]) {
      incompleteChunksRef.current[uuid] = [];
    }
    incompleteChunksRef.current[uuid].push(...chunk);

    const len = incompleteChunksRef.current[uuid].length;

    const finalizeAndStore = (bufferSize: number, axisOffset: number, startIdx: number) => {
      const completeBuffer = new Uint8Array(incompleteChunksRef.current[uuid].slice(0, bufferSize));
      incompleteChunksRef.current[uuid] = [];

      const view = new DataView(completeBuffer.buffer);
      const eventId = view.getUint16(0, true);
      const satelliteId = view.getUint8(2);
      const axisType = view.getUint8(3);
      const samples: number[] = [];

      for (let i = startIdx; i < view.byteLength; i += 2) {
        samples.push(view.getUint16(i, true));
      }

      const satOffset = (satelliteId - 1) * 7;
      let columnIndex: number | null = null;

      if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Gyro');
        columnIndex = satOffset + axisType;
      } else if (accCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Acc');
        columnIndex = satOffset + 3 + axisType;
      } else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Impact');
        columnIndex = satOffset + 6;
      }

      if (columnIndex !== null) {
        for (let i = 0; i < samples.length && i < 170; i++) {
          sensorMatrixRef.current[i][columnIndex] = samples[i];
        }

        console.log(`Stored data → Satellite ${satelliteId}, Col ${columnIndex}, Samples: ${samples.length}`);

        // Push update to parent chart
        const newData: { [key: string]: number[] } = {};
        for (let col = 0; col < 35; col++) {
          newData[`col${col}`] = sensorMatrixRef.current.map((row) => row[col] ?? 0);
        }
        onSensorData(newData);
      }
    };

    if (len >= 354) {
      finalizeAndStore(354, 0, 14);
    } else if (len === 353) {
      finalizeAndStore(353, 0, 13);
    }
  };

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


backup 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z', col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
       //   color: '#fff',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30}
        height={compact ? chartHeight / 2.2 : chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -400, yMax: 400, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -2000, yMax: 2000, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: 2.4, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
        />
      );
    });
  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const sensorMatrixRef = useRef<number[][]>(
    Array.from({ length: 170 }, () => Array(35).fill(null))
  );
  const incompleteChunksRef = useRef<{ [uuid: string]: number[] }>({});

  const deviceName = 'Real Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let userDataCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];

  const connectToDevice = async () => {
    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      const server = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);

      const impactService = await server.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await server.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await server.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await server.getPrimaryService(userServiceUUID);
      userDataCharacteristics = await userService.getCharacteristics();

      subscribeToAllNotifications();
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  const subscribeToAllNotifications = () => {
    const allCharacteristics = [
      ...accCharacteristics,
      ...gyroCharacteristics,
      ...impactCharacteristics,
      ...userDataCharacteristics,
    ];

    allCharacteristics.forEach((char) => {
      char.startNotifications().then(() => {
        char.addEventListener('characteristicvaluechanged', (event) =>
          handleCharacteristicNotification(event.target as BluetoothRemoteGATTCharacteristic)
        );
        console.log(`Notifications started for ${char.uuid}`);
      }).catch((e) => console.log('Notification error:', e));
    });
  };

  const handleCharacteristicNotification = (characteristic: BluetoothRemoteGATTCharacteristic) => {
    const uuid = characteristic.uuid;
    const value = characteristic.value!;
    const chunk = new Uint8Array(value.buffer);

    if (!incompleteChunksRef.current[uuid]) {
      incompleteChunksRef.current[uuid] = [];
    }
    incompleteChunksRef.current[uuid].push(...chunk);

    const len = incompleteChunksRef.current[uuid].length;

    const finalizeAndStore = (bufferSize: number, axisOffset: number, startIdx: number) => {
      const completeBuffer = new Uint8Array(incompleteChunksRef.current[uuid].slice(0, bufferSize));
      incompleteChunksRef.current[uuid] = [];

      const view = new DataView(completeBuffer.buffer);
      const eventId = view.getUint16(0, true);
      const satelliteId = view.getUint8(2);
      const axisType = view.getUint8(3);
      const samples: number[] = [];



      const satOffset = (satelliteId - 1) * 7;
      let columnIndex: number | null = null;
      let multipler =0;
      if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Gyro');
        columnIndex = satOffset + axisType;
        //samples.map(x => x / 16.4)
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
        multipler = 1/16.4;
      } else if (accCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Acc');
        columnIndex = satOffset + 3 + axisType;
        multipler = 0.2;
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, true));
        }

      } else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Impact');
        columnIndex = satOffset + 6;
        //samples.map(x => x *(2.42/4095))
        multipler = (2.42/4095);
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
      }

      if (columnIndex !== null) {
        for (let i = 0; i < samples.length && i < 170; i++) {
          console.log(samples);
          sensorMatrixRef.current[i][columnIndex] = samples[i]*multipler;
        }

        console.log(`Stored data → Satellite ${satelliteId}, Col ${columnIndex}, Samples: ${samples.length}`);

        // Push update to parent chart
        const newData: { [key: string]: number[] } = {};
        for (let col = 0; col < 35; col++) {
          newData[`col${col}`] = sensorMatrixRef.current.map((row) => row[col] ?? 0);
        }
        onSensorData(newData);
      }
    };

    if (len >= 354) {
      finalizeAndStore(354, 0, 14);
    } else if (len === 353) {
      finalizeAndStore(353, 0, 13);
    }
  };

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};


backup 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js';
import React, { useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35;
const DATA_LENGTH = 170;

// Sample Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

const labelMap: { [key: string]: string } = {
  col0: 'Gyro X', col1: 'Gyro Y', col2: 'Gyro Z', col3: 'Accel X', col4: 'Accel Y', col5: 'Accel Z', col6: 'Impact',
  col7: 'Gyro X', col8: 'Gyro Y', col9: 'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
}) => {
  const sampleFreq =
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = {
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label,
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
       //   color: '#fff',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30}
        height={compact ? chartHeight / 2.2 : chartHeight}
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-400}
          yAxisMax={400}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-2000}
          yAxisMax={2000}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={2.4}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -400, yMax: 400, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -2000, yMax: 2000, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: 2.4, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
        />
      );
    });
  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const sensorMatrixRef = useRef<number[][]>(
    Array.from({ length: 170 }, () => Array(35).fill(null))
  );
  const incompleteChunksRef = useRef<{ [uuid: string]: number[] }>({});

  const deviceName = 'Real Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let userDataCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];

  const connectToDevice = async () => {
    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      const server = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);

      const impactService = await server.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await server.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await server.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await server.getPrimaryService(userServiceUUID);
      userDataCharacteristics = await userService.getCharacteristics();

      subscribeToAllNotifications();
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  const subscribeToAllNotifications = () => {
    const allCharacteristics = [
      ...accCharacteristics,
      ...gyroCharacteristics,
      ...impactCharacteristics,
      ...userDataCharacteristics,
    ];

    allCharacteristics.forEach((char) => {
      char.startNotifications().then(() => {
        char.addEventListener('characteristicvaluechanged', (event) =>
          handleCharacteristicNotification(event.target as BluetoothRemoteGATTCharacteristic)
        );
        console.log(`Notifications started for ${char.uuid}`);
      }).catch((e) => console.log('Notification error:', e));
    });
  };

  const handleCharacteristicNotification = (characteristic: BluetoothRemoteGATTCharacteristic) => {
    const uuid = characteristic.uuid;
    const value = characteristic.value!;
    const chunk = new Uint8Array(value.buffer);

    if (!incompleteChunksRef.current[uuid]) {
      incompleteChunksRef.current[uuid] = [];
    }
    incompleteChunksRef.current[uuid].push(...chunk);

    const len = incompleteChunksRef.current[uuid].length;

    const finalizeAndStore = (bufferSize: number, axisOffset: number, startIdx: number) => {
      const completeBuffer = new Uint8Array(incompleteChunksRef.current[uuid].slice(0, bufferSize));
      incompleteChunksRef.current[uuid] = [];

      const view = new DataView(completeBuffer.buffer);
      const eventId = view.getUint16(0, true);
      const satelliteId = view.getUint8(2);
      const axisType = view.getUint8(3);
      const samples: number[] = [];



      const satOffset = (satelliteId - 1) * 7;
      let columnIndex: number | null = null;
      let multipler =0;
      if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Gyro');
        columnIndex = satOffset + axisType;
        //samples.map(x => x / 16.4)
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
        multipler = 1/16.4;
      } else if (accCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Acc');
        columnIndex = satOffset + 3 + axisType;
        multipler = 0.2;
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, true));
        }

      } else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Impact');
        columnIndex = satOffset + 6;
        //samples.map(x => x *(2.42/4095))
        multipler = (2.42/4095);
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
      }

      if (columnIndex !== null) {
        for (let i = 0; i < samples.length && i < 170; i++) {
          console.log(samples);
          sensorMatrixRef.current[i][columnIndex] = samples[i]*multipler;
        }

        console.log(`Stored data → Satellite ${satelliteId}, Col ${columnIndex}, Samples: ${samples.length}`);

        // Push update to parent chart
        const newData: { [key: string]: number[] } = {};
        for (let col = 0; col < 35; col++) {
          newData[`col${col}`] = sensorMatrixRef.current.map((row) => row[col] ?? 0);
        }
        onSensorData(newData);
      }
    };

    if (len >= 354) {
      finalizeAndStore(354, 0, 14);
    } else if (len === 353) {
      finalizeAndStore(353, 0, 13);
    }
  };

  return (
    <View style={styles.bleBar}>
      <Text style={styles.bleText}>{status}</Text>
      <TouchableOpacity
        onPress={connectToDevice}
        disabled={connected}
        style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
      >
        <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
      </TouchableOpacity>
    </View>
  );
};

working with half commented code 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'; // imported to create tabs 
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js'; // Chart rendering components 
import React, { useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native'; // React Native UI Components

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);


// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;   // Retrieves device dimensions for chart sizing
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35; // 35 data channels 7 per satellite 5 satellites each channel has 170 samples
const DATA_LENGTH = 170;

// Sampling Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

// Chart Dimensions
const GyroDimensions = 2000 ;
const AcceleroDimensions = 4000 ;
const ImpactDimensions = 2.4 ;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

// array column identifiers
const labelMap: { [key: string]: string } = {
  col0:  'Gyro X', col1:  'Gyro Y', col2:  'Gyro Z', col3:  'Accel X', col4:  'Accel Y', col5:  'Accel Z', col6:  'Impact',
  col7:  'Gyro X', col8:  'Gyro Y', col9:  'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({  // React Component to create and display a single chart block component
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
}) => {
  const sampleFreq =   // creates the charts X axis values (ms) based on the chart title and associated sampling freq
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :  
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = { // Maps input series to Chart.js datasets.
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label, // using label map converts keys (col0, col1 etc) into associated labels)
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = { // configures both axis, x in (ms) y axis as a prop, also configures grid lines and legend
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
       //   color: '#fff',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30} // width and height calculations just work im not sure - 
        height={compact ? chartHeight / 2.2 : chartHeight}         // why the numbers work as they are 
      />
    </View>
  );
};

const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);


  ///////////// How "series" works  //////////////////////////////////////////////////////
  // Let’s say you are rendering an Accelerometer chart for Satellite 1.
  //                    const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);
  // we would get this ['col0', 'col1', 'col2', 'col3', 'col4', 'col5', 'col6']
  // then for the accelerometer series={getSeries(keys.slice(3, 6))}  // ['col3', 'col4', 'col5']
  // this becomes       series = [
  //                      { label: 'col3', data: sensorData['col3'] },
  //                      { label: 'col4', data: sensorData['col4'] },
  //                      { label: 'col5', data: sensorData['col5'] },
  //                    ];
  // Each entry in series then becomes a separate line on the chart.                    
  //                      datasets: series.map((s, i) => ({
  //                      label: labelMap[s.label] || s.label,  // Converts col3 -> "Accel X"
  //                      data: s.data,                         // 170 samples
  //                      ...
  //                    }))
  // How it configures for all 5 charts //
  // Each SensorTab is passed a startIndex, which is:
  //                    <SensorTab startIndex={14} sensorData={sensorData} />  // Satellite 3
  //                    startIndex = 7 * satelliteIndex
  // This offset tells the tab which set of 7 columns (out of 35) to use for that satellite.
  //
  //
  /////////////////////////////////////////////////////////////////////////////////////
  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-AcceleroDimensions}
          yAxisMax={AcceleroDimensions}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-GyroDimensions}
          yAxisMax={GyroDimensions}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={ImpactDimensions}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -AcceleroDimensions, yMax: AcceleroDimensions, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -GyroDimensions, yMax: GyroDimensions, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: ImpactDimensions, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
        />
      );
    });
  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {     // initialies the array 35 columns 170 rows 
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);                                     // initiallizes all values to 0
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const sensorMatrixRef = useRef<number[][]>(
    Array.from({ length: 170 }, () => Array(35).fill(null))
  );
  

  const incompleteChunksRef = useRef<{ [uuid: string]: number[] }>({});

  const deviceName = 'Real Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let userDataCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];


  const connectToDevice = async () => {
    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      const server = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);

      const impactService = await server.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await server.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await server.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await server.getPrimaryService(userServiceUUID);
      userDataCharacteristics = await userService.getCharacteristics();

      subscribeToAllNotifications();
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  const subscribeToAllNotifications = () => {
    const allCharacteristics = [
      ...accCharacteristics,
      ...gyroCharacteristics,
      ...impactCharacteristics,
      ...userDataCharacteristics,
    ];

    allCharacteristics.forEach((char) => {
      char.startNotifications().then(() => {
        char.addEventListener('characteristicvaluechanged', (event) =>
          handleCharacteristicNotification(event.target as BluetoothRemoteGATTCharacteristic)
        );
        console.log(`Notifications started for ${char.uuid}`);
      }).catch((e) => console.log('Notification error:', e));
    });
  };

  const handleCharacteristicNotification = (characteristic: BluetoothRemoteGATTCharacteristic) => {
    const uuid = characteristic.uuid;
    const value = characteristic.value!;
    const chunk = new Uint8Array(value.buffer);

    if (!incompleteChunksRef.current[uuid]) {
      incompleteChunksRef.current[uuid] = [];
    }
    incompleteChunksRef.current[uuid].push(...chunk);

    const len = incompleteChunksRef.current[uuid].length;

    const finalizeAndStore = (bufferSize: number, axisOffset: number, startIdx: number) => {
      const completeBuffer = new Uint8Array(incompleteChunksRef.current[uuid].slice(0, bufferSize));
      incompleteChunksRef.current[uuid] = [];

      const view = new DataView(completeBuffer.buffer);
      const eventId = view.getUint16(0, true);
      const satelliteId = view.getUint8(2);
      const axisType = view.getUint8(3);
      const samples: number[] = [];



      const satOffset = (satelliteId - 1) * 7;
      let columnIndex: number | null = null;
      let multipler =0;
      if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Gyro');
        columnIndex = satOffset + axisType;
        // samples.map(x => x / 16.4)
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
        multipler = 1/16.4;
      } else if (accCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Acc');
        columnIndex = satOffset + 3 + axisType;
        multipler = 0.2;
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, true));
        }

      } else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Impact');
        columnIndex = satOffset + 6;
        // samples.map(x => x *(2.42/4095))
        multipler = (2.42/4095);
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
      }

      if (columnIndex !== null) {
        for (let i = 0; i < samples.length && i < 170; i++) {
          console.log(samples);
          sensorMatrixRef.current[i][columnIndex] = samples[i]*multipler;
        }

        console.log(`Stored data → Satellite ${satelliteId}, Col ${columnIndex}, Samples: ${samples.length}`);

        // Push update to parent chart
        const newData: { [key: string]: number[] } = {};
        for (let col = 0; col < 35; col++) {
          newData[`col${col}`] = sensorMatrixRef.current.map((row) => row[col] ?? 0);
        }
        onSensorData(newData);
      }
    };

    if (len >= 354) {
      finalizeAndStore(354, 0, 14);
    } else if (len === 353) {
      finalizeAndStore(353, 0, 13);
    }
  };

//const downloadCSV = (sensorMatrix: number[][]) => {
//  if (!Array.isArray(sensorMatrix) || !Array.isArray(sensorMatrix[0])) {
//    alert('No data to export!');
//    return;
//  }
//  const rows = sensorMatrix.map(row =>
//    row.map(val => (val !== null ? val.toFixed(4) : '0')).join(',')
//  );
//  const csvContent = rows.join('\n');
//  const now = new Date();
//  const fileName = `SensorData_${now.toISOString().slice(0,19).replace(/:/g,"-")}.csv`;
//
//  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
//  const url = URL.createObjectURL(blob);
//
//  const a = document.createElement('a');
//  a.href = url;
//  a.download = fileName;
//  document.body.appendChild(a);
//  a.click();
//  document.body.removeChild(a);
//  URL.revokeObjectURL(url);
//};

const downloadCSV = async (sensorMatrix: number[][]) => {
  if (!Array.isArray(sensorMatrix) || !Array.isArray(sensorMatrix[0])) {
    alert('No data to export!');
    return;
  }
  const rows = sensorMatrix.map(row =>
    row.map(val => (val !== null ? val.toFixed(4) : '0')).join(',')
  );
  const csvContent = rows.join('\n');
  const now = new Date();
  const defaultName = `SensorData_${now.toISOString().slice(0,19).replace(/:/g,"-")}.csv`;

  // Check if File System Access API is available
  if ('showSaveFilePicker' in window) {
    try {
      // @ts-ignore
      const handle = await window.showSaveFilePicker({
        suggestedName: defaultName,
        types: [
          {
            description: 'CSV Files',
            accept: { 'text/csv': ['.csv'] },
          },
        ],
      });
      const writable = await handle.createWritable();
      await writable.write(csvContent);
      await writable.close();
      alert('File saved successfully!');
    } catch (e) {
      // if (e.name !== 'AbortError') alert('Could not save file: ' + e.message); // add back if you want the catch 
    }
  } else {
    // Fallback for unsupported browsers: trigger download as before
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = defaultName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

const loadCSVAndPlot = async () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.csv';
  input.onchange = async (e: any) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    const lines = text.trim().split('\n');
    const matrix: number[][] = lines.map(line =>
      line.split(',').map(x => parseFloat(x))
    );

    const newData: { [key: string]: number[] } = {};
    for (let col = 0; col < 35; col++) {
      newData[`col${col}`] = matrix.map(row => row[col] ?? 0);
    }

    onSensorData(newData);
  };

  input.click();

};

  return (
    <View style={[styles.bleBar, { flexDirection: 'column', alignItems: 'center' }]}>
  <Text style={styles.bleText}>{status}</Text>
  <View style={{ flexDirection: 'row', gap: 10, marginVertical: 4 }}>
    <TouchableOpacity
      onPress={connectToDevice}
      disabled={connected}
      style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
    >
      <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
    </TouchableOpacity>
          <TouchableOpacity
        onPress={() => downloadCSV(sensorMatrixRef.current)}
        style={styles.bleButton}
      >
        <Text style={styles.bleButtonText}>Export CSV</Text>
      </TouchableOpacity>
    <TouchableOpacity
      onPress={loadCSVAndPlot}
      style={styles.bleButton}
    >
      <Text style={styles.bleButtonText}>Plot Saved</Text>
    </TouchableOpacity>
  </View>
</View>
  );
  
};

Working without start time capability, 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'; // imported to create tabs 
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js'; // Chart rendering components 
import React, { useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native'; // React Native UI Components

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);


// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;   // Retrieves device dimensions for chart sizing
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35; // 35 data channels 7 per satellite 5 satellites each channel has 170 samples
const DATA_LENGTH = 170;

// Sampling Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

// Chart Dimensions
const GyroDimensions = 2000 ;
const AcceleroDimensions = 4000 ;
const ImpactDimensions = 2.4 ;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

// array column identifiers
const labelMap: { [key: string]: string } = {
  col0:  'Gyro X', col1:  'Gyro Y', col2:  'Gyro Z', col3:  'Accel X', col4:  'Accel Y', col5:  'Accel Z', col6:  'Impact',
  col7:  'Gyro X', col8:  'Gyro Y', col9:  'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({  // React Component to create and display a single chart block component
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
}) => {
  const sampleFreq =   // creates the charts X axis values (ms) based on the chart title and associated sampling freq
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :  
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
    `${(idx * (1000 / sampleFreq)).toFixed(1)}`
  );

  const chartData = { // Maps input series to Chart.js datasets.
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label, // using label map converts keys (col0, col1 etc) into associated labels)
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = { // configures both axis, x in (ms) y axis as a prop, also configures grid lines and legend
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
       //   color: '#fff',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30} // width and height calculations just work im not sure - 
        height={compact ? chartHeight / 2.2 : chartHeight}         // why the numbers work as they are 
      />
    </View>
  );
};


const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));
    

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);


  ///////////// How "series" works  //////////////////////////////////////////////////////
  // Let’s say you are rendering an Accelerometer chart for Satellite 1.
  //                    const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);
  // we would get this ['col0', 'col1', 'col2', 'col3', 'col4', 'col5', 'col6']
  // then for the accelerometer series={getSeries(keys.slice(3, 6))}  // ['col3', 'col4', 'col5']
  // this becomes       series = [
  //                      { label: 'col3', data: sensorData['col3'] },
  //                      { label: 'col4', data: sensorData['col4'] },
  //                      { label: 'col5', data: sensorData['col5'] },
  //                    ];
  // Each entry in series then becomes a separate line on the chart.                    
  //                      datasets: series.map((s, i) => ({
  //                      label: labelMap[s.label] || s.label,  // Converts col3 -> "Accel X"
  //                      data: s.data,                         // 170 samples
  //                      ...
  //                    }))
  // How it configures for all 5 charts //
  // Each SensorTab is passed a startIndex, which is:
  //                    <SensorTab startIndex={14} sensorData={sensorData} />  // Satellite 3
  //                    startIndex = 7 * satelliteIndex
  // This offset tells the tab which set of 7 columns (out of 35) to use for that satellite.
  //
  //
  /////////////////////////////////////////////////////////////////////////////////////
  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-AcceleroDimensions}
          yAxisMax={AcceleroDimensions}
          yAxisTitle="Acceleration (g)"
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-GyroDimensions}
          yAxisMax={GyroDimensions}
          yAxisTitle="Angular Velocity (°/s)"
        />
      </View>
      <View style={styles.bottomRow}>
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={ImpactDimensions}
          yAxisTitle="Impact (V)"
        />
      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -AcceleroDimensions, yMax: AcceleroDimensions, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -GyroDimensions, yMax: GyroDimensions, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: ImpactDimensions, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
        />
      );
    });
  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {     // initialies the array 35 columns 170 rows 
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);                                     // initiallizes all values to 0
    }
    return data;
  });

  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const sensorMatrixRef = useRef<number[][]>(
    Array.from({ length: 170 }, () => Array(35).fill(null))
  );
  

  const incompleteChunksRef = useRef<{ [uuid: string]: number[] }>({});

  const deviceName = 'Dummy Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let userDataCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];

  const sensorStartTimesRef = useRef<number[]>(Array(15).fill(null)); // start time array 15 vales 3 sensors x5 satellites


  const connectToDevice = async () => {
    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      const server = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);

      const impactService = await server.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await server.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await server.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await server.getPrimaryService(userServiceUUID);
      userDataCharacteristics = await userService.getCharacteristics();

      subscribeToAllNotifications();
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  const subscribeToAllNotifications = () => {
    const allCharacteristics = [
      ...accCharacteristics,
      ...gyroCharacteristics,
      ...impactCharacteristics,
      ...userDataCharacteristics,
    ];

    allCharacteristics.forEach((char) => {
      char.startNotifications().then(() => {
        char.addEventListener('characteristicvaluechanged', (event) =>
          handleCharacteristicNotification(event.target as BluetoothRemoteGATTCharacteristic)
        );
        console.log(`Notifications started for ${char.uuid}`);
      }).catch((e) => console.log('Notification error:', e));
    });
  };

  const handleCharacteristicNotification = (characteristic: BluetoothRemoteGATTCharacteristic) => {
    const uuid = characteristic.uuid;
    const value = characteristic.value!;
    const chunk = new Uint8Array(value.buffer);

    if (!incompleteChunksRef.current[uuid]) {
      incompleteChunksRef.current[uuid] = [];
    }
    incompleteChunksRef.current[uuid].push(...chunk);

    const len = incompleteChunksRef.current[uuid].length;

    const finalizeAndStore = (bufferSize: number, axisOffset: number, startIdx: number) => {
      const completeBuffer = new Uint8Array(incompleteChunksRef.current[uuid].slice(0, bufferSize));
      incompleteChunksRef.current[uuid] = [];

      const view = new DataView(completeBuffer.buffer);
      const eventId = view.getUint16(0, true);
      const satelliteId = view.getUint8(2);
      const axisType = view.getUint8(3);
      const startTime = view.getUint32(4);
      const samples: number[] = [];
      const impactTimes: number[] = [];
      const gyroTimes: number[] = [];
      const acceleroTimes: number[] = [];
      



      const satOffset = (satelliteId - 1) * 7;
      let columnIndex: number | null = null;
      let multipler =0;
      if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Gyro');
        columnIndex = satOffset + axisType;
        gyroTimes.push(view.getUint32(4, false));
        // samples.map(x => x / 16.4)
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
        
        //  for (let i = 4; i < 16; i += 4) {
        //    gyroTimes.push(view.getUint32(i, false));
        //  }

        console.log(gyroTimes);
        multipler = 1/16.4;
      } else if (accCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Acc');
        columnIndex = satOffset + 3 + axisType;
        acceleroTimes.push(view.getUint32(4, false));
        multipler = 0.2;
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, true));
        }

      } else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('Impact');
        columnIndex = satOffset + 6;
        impactTimes.push(view.getUint32(4, false));
        // samples.map(x => x *(2.42/4095))
        multipler = (2.42/4095);
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false));
        }
      }

      if (columnIndex !== null) {
        for (let i = 0; i < samples.length && i < 170; i++) {
          console.log(samples);
          sensorMatrixRef.current[i][columnIndex] = samples[i]*multipler;
        }

        console.log(`Stored data → Satellite ${satelliteId}, Col ${columnIndex}, Samples: ${samples.length}`);

        // Push update to parent chart
        const newData: { [key: string]: number[] } = {};
        for (let col = 0; col < 35; col++) {
          newData[`col${col}`] = sensorMatrixRef.current.map((row) => row[col] ?? 0);
        }
        onSensorData(newData);
      }
    };

    if (len >= 354) {
      finalizeAndStore(354, 0, 14);
    } else if (len === 353) {
      finalizeAndStore(353, 0, 13);
    }
  };

//const downloadCSV = (sensorMatrix: number[][]) => {
//  if (!Array.isArray(sensorMatrix) || !Array.isArray(sensorMatrix[0])) {
//    alert('No data to export!');
//    return;
//  }
//  const rows = sensorMatrix.map(row =>
//    row.map(val => (val !== null ? val.toFixed(4) : '0')).join(',')
//  );
//  const csvContent = rows.join('\n');
//  const now = new Date();
//  const fileName = `SensorData_${now.toISOString().slice(0,19).replace(/:/g,"-")}.csv`;
//
//  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
//  const url = URL.createObjectURL(blob);
//
//  const a = document.createElement('a');
//  a.href = url;
//  a.download = fileName;
//  document.body.appendChild(a);
//  a.click();
//  document.body.removeChild(a);
//  URL.revokeObjectURL(url);
//};

const downloadCSV = async (sensorMatrix: number[][]) => {
  if (!Array.isArray(sensorMatrix) || !Array.isArray(sensorMatrix[0])) {
    alert('No data to export!');
    return;
  }
  const rows = sensorMatrix.map(row =>
    row.map(val => (val !== null ? val.toFixed(4) : '0')).join(',')
  );
  const csvContent = rows.join('\n');
  const now = new Date();
  const defaultName = `SensorData_${now.toISOString().slice(0,19).replace(/:/g,"-")}.csv`;

  // Check if File System Access API is available
  if ('showSaveFilePicker' in window) {
    try {
      // @ts-ignore
      const handle = await window.showSaveFilePicker({
        suggestedName: defaultName,
        types: [
          {
            description: 'CSV Files',
            accept: { 'text/csv': ['.csv'] },
          },
        ],
      });
      const writable = await handle.createWritable();
      await writable.write(csvContent);
      await writable.close();
      alert('File saved successfully!');
    } catch (e) {
      // if (e.name !== 'AbortError') alert('Could not save file: ' + e.message); // add back if you want the catch 
    }
  } else {
    // Fallback for unsupported browsers: trigger download as before
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = defaultName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

const loadCSVAndPlot = async () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.csv';
  input.onchange = async (e: any) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    const lines = text.trim().split('\n');
    const matrix: number[][] = lines.map(line =>
      line.split(',').map(x => parseFloat(x))
    );

    const newData: { [key: string]: number[] } = {};
    for (let col = 0; col < 35; col++) {
      newData[`col${col}`] = matrix.map(row => row[col] ?? 0);
    }

    onSensorData(newData);
  };

  input.click();

};

  return (
    <View style={[styles.bleBar, { flexDirection: 'column', alignItems: 'center' }]}>
  <Text style={styles.bleText}>{status}</Text>
  <View style={{ flexDirection: 'row', gap: 10, marginVertical: 4 }}>
    <TouchableOpacity
      onPress={connectToDevice}
      disabled={connected}
      style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
    >
      <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
    </TouchableOpacity>
          <TouchableOpacity
        onPress={() => downloadCSV(sensorMatrixRef.current)}
        style={styles.bleButton}
      >
        <Text style={styles.bleButtonText}>Download to CSV</Text>
      </TouchableOpacity>
    <TouchableOpacity
      onPress={loadCSVAndPlot}
      style={styles.bleButton}
    >
      <Text style={styles.bleButtonText}>Upload Data</Text>
    </TouchableOpacity>
  </View>
</View>
  );
  
};

backup code 

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'; // imported to create tabs 
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js'; // Chart rendering components 
import React, { useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native'; // React Native UI Components

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

export const sensorStartTimesRef = useRef<number[]>(Array(15).fill(0));
export const rawStartTimesRef = useRef<number[]>(Array(15).fill(0));

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;   // Retrieves device dimensions for chart sizing
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35; // 35 data channels 7 per satellite 5 satellites each channel has 170 samples
const DATA_LENGTH = 170;

// Sampling Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

// Chart Dimensions
const GyroDimensions = 2000 ;
const AcceleroDimensions = 4000 ;
const ImpactDimensions = 2.4 ;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

// array column identifiers
const labelMap: { [key: string]: string } = {
  col0:  'Gyro X', col1:  'Gyro Y', col2:  'Gyro Z', col3:  'Accel X', col4:  'Accel Y', col5:  'Accel Z', col6:  'Impact',
  col7:  'Gyro X', col8:  'Gyro Y', col9:  'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false, startTimeOffset = 0,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
  startTimeOffset?: number;
}) => {
  const sampleFreq =   // creates the charts X axis values (ms) based on the chart title and associated sampling freq
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :  
    SamplingFreqImpact;

  const timeLabels = series[0]?.data.map((_, idx) =>
  `${((idx * (1000 / sampleFreq)) + startTimeOffset).toFixed(1)}`
);

  const chartData = { // Maps input series to Chart.js datasets.
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label, // using label map converts keys (col0, col1 etc) into associated labels)
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = { // configures both axis, x in (ms) y axis as a prop, also configures grid lines and legend
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
       //   color: '#fff',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30} // width and height calculations just work im not sure - 
        height={compact ? chartHeight / 2.2 : chartHeight}         // why the numbers work as they are 
      />
    </View>
  );
};


const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const satIndex = startIndex / 7;
  const gyroOffset = sensorStartTimesRef.current[satIndex * 3 + 0] || 0;
  const accelOffset = sensorStartTimesRef.current[satIndex * 3 + 1] || 0;
  const impactOffset = sensorStartTimesRef.current[satIndex * 3 + 2] || 0;
  
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));
    

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);


  ///////////// How "series" works  //////////////////////////////////////////////////////
  // Let’s say you are rendering an Accelerometer chart for Satellite 1.
  //                    const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);
  // we would get this ['col0', 'col1', 'col2', 'col3', 'col4', 'col5', 'col6']
  // then for the accelerometer series={getSeries(keys.slice(3, 6))}  // ['col3', 'col4', 'col5']
  // this becomes       series = [
  //                      { label: 'col3', data: sensorData['col3'] },
  //                      { label: 'col4', data: sensorData['col4'] },
  //                      { label: 'col5', data: sensorData['col5'] },
  //                    ];
  // Each entry in series then becomes a separate line on the chart.                    
  //                      datasets: series.map((s, i) => ({
  //                      label: labelMap[s.label] || s.label,  // Converts col3 -> "Accel X"
  //                      data: s.data,                         // 170 samples
  //                      ...
  //                    }))
  // How it configures for all 5 charts //
  // Each SensorTab is passed a startIndex, which is:
  //                    <SensorTab startIndex={14} sensorData={sensorData} />  // Satellite 3
  //                    startIndex = 7 * satelliteIndex
  // This offset tells the tab which set of 7 columns (out of 35) to use for that satellite.
  //
  //
  /////////////////////////////////////////////////////////////////////////////////////

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-AcceleroDimensions}
          yAxisMax={AcceleroDimensions}
          yAxisTitle="Acceleration (g)"
          startTimeOffset={accelOffset}
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-GyroDimensions}
          yAxisMax={GyroDimensions}
          yAxisTitle="Angular Velocity (°/s)"
          startTimeOffset={gyroOffset}
        />
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={ImpactDimensions}
          yAxisTitle="Impact (V)"
          startTimeOffset={impactOffset}
        />

      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -AcceleroDimensions, yMax: AcceleroDimensions, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -GyroDimensions, yMax: GyroDimensions, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: ImpactDimensions, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    const baseIdx = i * 3;
    const gyroOffset = sensorStartTimesRef.current[baseIdx + 0] || 0;
    const accelOffset = sensorStartTimesRef.current[baseIdx + 1] || 0;
    const impactOffset = sensorStartTimesRef.current[baseIdx + 2] || 0;

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      const offset = type === 'Impact' ? impactOffset : type === 'Gyroscope' ? gyroOffset : accelOffset;
    
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
          startTimeOffset={offset}
        />
      );
    });

  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {     // initialies the array 35 columns 170 rows 
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);                                     // initiallizes all values to 0
    }
    return data;
  });

  //      // TEMPORARY: Hardcoded start times for testing x-axis offsets
  //      useEffect(() => {
  //        const dummyOffsets = [
  //          0, 1, 2,    // Satellite 1: Gyro, Accel, Impact
  //          3, 4, 5,   // Satellite 2
  //          6, 7, 8,   // Satellite 3
  //          9, 10, 11, // Satellite 4
  //          12, 13, 14 // Satellite 5
  //        ];
  //        sensorStartTimesRef.current = dummyOffsets;
  //        console.log('Hardcoded sensor start times applied:', sensorStartTimesRef.current);
  //      }, []);


  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const sensorMatrixRef = useRef<number[][]>(
    Array.from({ length: 170 }, () => Array(35).fill(null))
  );
  

  const incompleteChunksRef = useRef<{ [uuid: string]: number[] }>({});

  const deviceName = 'Real Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let userDataCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];

  // const sensorStartTimesRef = useRef<number[]>(Array(15).fill(null)); // start time array 15 vales 3 sensors x5 satellites


    //   sensorStartTimesRef.current = [      
    //   Gyro1, Accel1, Impact1,   // indexes 0–2     
    //   Gyro2, Accel2, Impact2,   // 3–5           This is how the code will store the times
    //   Gyro3, Accel3, Impact3,   // 6–8           This is how the code will store the times
    //   Gyro4, Accel4, Impact4,   // 9–11      
    //   Gyro5, Accel5, Impact5    // 12–14     
    // ]      


  const connectToDevice = async () => {
    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      const server = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);

      const impactService = await server.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await server.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await server.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await server.getPrimaryService(userServiceUUID);
      userDataCharacteristics = await userService.getCharacteristics();

      subscribeToAllNotifications();
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  const subscribeToAllNotifications = () => {
    const allCharacteristics = [
      ...accCharacteristics,
      ...gyroCharacteristics,
      ...impactCharacteristics,
      ...userDataCharacteristics,
    ];

    allCharacteristics.forEach((char) => {
      char.startNotifications().then(() => {
        char.addEventListener('characteristicvaluechanged', (event) =>
          handleCharacteristicNotification(event.target as BluetoothRemoteGATTCharacteristic)
        );
        console.log(`Notifications started for ${char.uuid}`);
      }).catch((e) => console.log('Notification error:', e));
    });
  };

  const handleCharacteristicNotification = (characteristic: BluetoothRemoteGATTCharacteristic) => {
    const uuid = characteristic.uuid;
    const value = characteristic.value!;
    const chunk = new Uint8Array(value.buffer);

    if (!incompleteChunksRef.current[uuid]) {
      incompleteChunksRef.current[uuid] = [];
    }
    incompleteChunksRef.current[uuid].push(...chunk);

    const len = incompleteChunksRef.current[uuid].length;
    const NormalizeBySensorType = () => {
        const groups = {
          gyro:   [0, 3, 6, 9, 12],
          accel:  [1, 4, 7, 10, 13],
          impact: [2, 5, 8, 11, 14],
        };
      
        Object.values(groups).forEach(indices => {
          if (indices.every(i => sensorStartTimesRef.current[i] > 0)) {
            const minStart = Math.min(...indices.map(i => sensorStartTimesRef.current[i]));
            indices.forEach(i => {
              sensorStartTimesRef.current[i] -= minStart;
            });
          
            const labelPrefix = indices === groups.gyro
              ? 'Gyro' : indices === groups.accel
              ? 'Accel' : 'Impact';
          
            console.log(`✅ Normalized ${labelPrefix} start times:`);
            indices.forEach((i, idx) => {
              console.log(`${labelPrefix}${idx + 1}: ${sensorStartTimesRef.current[i]} ms`);
            });
          }
        });
      };

    const finalizeAndStore = (bufferSize: number, axisOffset: number, startIdx: number) => {
      const completeBuffer = new Uint8Array(incompleteChunksRef.current[uuid].slice(0, bufferSize));
      incompleteChunksRef.current[uuid] = [];

      const view = new DataView(completeBuffer.buffer);
      const eventId = view.getUint16(0, true);
      const satelliteId = view.getUint8(2);
      const axisType = view.getUint8(3);
      // const startTime = view.getUint32(4);
      const samples: number[] = [];
      // const impactTimes: number[] = [];
      // const gyroTimes: number[] = [];
      // const acceleroTimes: number[] = [];
      



      const satOffset = (satelliteId - 1) * 7;
      let columnIndex: number | null = null;
      let multipler =0;
   

      // test
      const startTime = view.getUint32(4, true); // grab the sensor's start time
      const baseIndex = (satelliteId - 1) * 3;

      if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('🟢 Gyro');
      
        columnIndex = satOffset + axisType;
        if (sensorStartTimesRef.current[baseIndex + 0] === 0) {
          rawStartTimesRef.current[baseIndex + 0] = startTime;
          sensorStartTimesRef.current[baseIndex + 0] = startTime;
          console.log(`Gyro start time for Sat ${satelliteId}: ${startTime}`);
          NormalizeBySensorType();
        }
      
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false)); // big endian
        }
        multipler = 1 / 16.4;
      }
      
      else if (accCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('🔵 Accel');
      
        columnIndex = satOffset + 3 + axisType;
        if (sensorStartTimesRef.current[baseIndex + 1] === 0) {
          rawStartTimesRef.current[baseIndex + 1] = startTime;
          sensorStartTimesRef.current[baseIndex + 1] = startTime;
          console.log(`Accel start time for Sat ${satelliteId}: ${startTime}`);
          NormalizeBySensorType();
        }
      
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, true)); // little endian
        }
        multipler = 0.2;
      }
      
      else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('🔴 Impact');
      
        columnIndex = satOffset + 6;
        if (sensorStartTimesRef.current[baseIndex + 2] === 0) {
          rawStartTimesRef.current[baseIndex + 2] = startTime;
          sensorStartTimesRef.current[baseIndex + 2] = startTime;
          console.log(`Impact start time for Sat ${satelliteId}: ${startTime}`);
          NormalizeBySensorType();
        }
      
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false)); // big endian
        }
        multipler = 2.42 / 4095;
      }
      // new start time logic 
      

      // new start time logic

      
      // Normalize start times once all 15 are populated
//    if (sensorStartTimesRef.current.every(t => t > 0)) {
//      const minStart = Math.min(...sensorStartTimesRef.current);
//      sensorStartTimesRef.current = sensorStartTimesRef.current.map(t => t - minStart);
//      console.log('✅ Normalized start times (in ms):', sensorStartTimesRef.current);
//    
//      // Optional labeled debug log for clarity
//      [
//        'Gyro1', 'Accel1', 'Impact1',
//        'Gyro2', 'Accel2', 'Impact2',
//        'Gyro3', 'Accel3', 'Impact3',
//        'Gyro4', 'Accel4', 'Impact4',
//        'Gyro5', 'Accel5', 'Impact5'
//      ].forEach((label, i) => {
//        console.log(`${label}: ${sensorStartTimesRef.current[i]} ms`);
//      });
//    }

      // test
      //       if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
      //         console.log('Gyro');
      //         columnIndex = satOffset + axisType;
      //         // gyroTimes.push(view.getUint32(4, false));
      //         // samples.map(x => x / 16.4)
      //         for (let i = startIdx; i < view.byteLength; i += 2) {
      //           samples.push(view.getInt16(i, false));
      //         }
      //         
      //         //  for (let i = 4; i < 16; i += 4) {
      //         //    gyroTimes.push(view.getUint32(i, false));
      //         //  }
//       
      //         console.log(gyroTimes);
      //         multipler = 1/16.4;
      //       } else if (accCharacteristics.some((c) => c.uuid === uuid)) {
      //         console.log('Acc');
      //         columnIndex = satOffset + 3 + axisType;
      //         // acceleroTimes.push(view.getUint32(4, false));
      //         multipler = 0.2;
      //         for (let i = startIdx; i < view.byteLength; i += 2) {
      //           samples.push(view.getInt16(i, true));
      //         }
//       
      //       } else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
      //         console.log('Impact');
      //         columnIndex = satOffset + 6;
      //         // impactTimes.push(view.getUint32(4, false));
      //         // samples.map(x => x *(2.42/4095))
      //         multipler = (2.42/4095);
      //         for (let i = startIdx; i < view.byteLength; i += 2) {
      //           samples.push(view.getInt16(i, false));
      //         }
      //       }

      if (columnIndex !== null) {
        for (let i = 0; i < samples.length && i < 170; i++) {
          console.log(samples);
          sensorMatrixRef.current[i][columnIndex] = samples[i]*multipler;
        }

        console.log(`Stored data → Satellite ${satelliteId}, Col ${columnIndex}, Samples: ${samples.length}`);

        // Push update to parent chart
        const newData: { [key: string]: number[] } = {};
        for (let col = 0; col < 35; col++) {
          newData[`col${col}`] = sensorMatrixRef.current.map((row) => row[col] ?? 0);
        }
        onSensorData(newData);
      }
    };

    if (len >= 354) {
      finalizeAndStore(354, 0, 14);
    } else if (len === 353) {
      finalizeAndStore(353, 0, 13);
    }
  };

const downloadCSV = async (sensorMatrix: number[][]) => {
  if (!Array.isArray(sensorMatrix) || !Array.isArray(sensorMatrix[0])) {
    alert('No data to export!');
    return;
  }
 const rows = sensorMatrix.map((row, i) => {
  const rowValues = row.map(val => (val !== null ? val.toFixed(4) : '0'));

  const raw = i < 15 ? rawStartTimesRef.current[i].toString() : '';
  const normalized = i < 15 ? sensorStartTimesRef.current[i].toString() : '';

  return [...rowValues, raw, normalized].join(',');
});

// === Headers: Descriptive labels for each column ===
const sensorLabels = [
  'Gyro X', 'Gyro Y', 'Gyro Z',
  'Accel X', 'Accel Y', 'Accel Z',
  'Impact'
];

const headers = Array.from({ length: 35 }, (_, i) => {
  const sensorIdx = i % 7;
  const satNum = Math.floor(i / 7) + 1;
  return `${sensorLabels[sensorIdx]} ${satNum}`;
}).concat('RawStartTime', 'NormalizedStartTime');

rows.unshift(headers.join(','));

const csvContent = rows.join('\n');

  const now = new Date();
  const defaultName = `SensorData_${now.toISOString().slice(0,19).replace(/:/g,"-")}.csv`;

  // Check if File System Access API is available
  if ('showSaveFilePicker' in window) {
    try {
      // @ts-ignore
      const handle = await window.showSaveFilePicker({
        suggestedName: defaultName,
        types: [
          {
            description: 'CSV Files',
            accept: { 'text/csv': ['.csv'] },
          },
        ],
      });
      const writable = await handle.createWritable();
      await writable.write(csvContent);
      await writable.close();
      alert('File saved successfully!');
    } catch (e) {
      // if (e.name !== 'AbortError') alert('Could not save file: ' + e.message); // add back if you want the catch 
    }
  } else {
    // Fallback for unsupported browsers: trigger download as before
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = defaultName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

const loadCSVAndPlot = async () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.csv';
  input.onchange = async (e: any) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    const lines = text.trim().split('\n');

    if (lines.length < 2) {
      alert("CSV file is empty or invalid.");
      return;
    }

    // Skip header and parse data rows
    const dataLines = lines.slice(1);

    const matrix: number[][] = dataLines.map(line =>
      line.split(',').map(x => parseFloat(x))
    );

    // === Rebuild sensorData from columns 0–34
    const newData: { [key: string]: number[] } = {};
    for (let col = 0; col < 35; col++) {
      newData[`col${col}`] = matrix.map(row => row[col] ?? 0);
    }

    // === Restore raw and normalized start times (columns 35, 36) from first 15 rows
    for (let i = 0; i < 15; i++) {
      const row = matrix[i];
      const raw = row[35];
      const normalized = row[36];
      if (!isNaN(raw)) rawStartTimesRef.current[i] = raw;
      if (!isNaN(normalized)) sensorStartTimesRef.current[i] = normalized;
    }

    // Update sensorMatrixRef.current so downloadCSV gets real data
  for (let row = 0; row < 170; row++) {
    for (let col = 0; col < 35; col++) {
      sensorMatrixRef.current[row][col] = matrix[row]?.[col] ?? 0;
    }
  }

    onSensorData(newData);
  };

  input.click();
};


  return (
    <View style={[styles.bleBar, { flexDirection: 'column', alignItems: 'center' }]}>
  <Text style={styles.bleText}>{status}</Text>
  <View style={{ flexDirection: 'row', gap: 10, marginVertical: 4 }}>
    <TouchableOpacity
      onPress={connectToDevice}
      disabled={connected}
      style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
    >
      <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
    </TouchableOpacity>
          <TouchableOpacity
        onPress={() => downloadCSV(sensorMatrixRef.current)}
        style={styles.bleButton}
      >
        <Text style={styles.bleButtonText}>Download to CSV</Text>
      </TouchableOpacity>
    <TouchableOpacity
      onPress={loadCSVAndPlot}
      style={styles.bleButton}
    >
      <Text style={styles.bleButtonText}>Upload Data</Text>
    </TouchableOpacity>
  </View>
</View>
  );
  
};

import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'; // imported to create tabs 
import {
  CategoryScale,
  Chart as ChartJS,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
} from 'chart.js'; // Chart rendering components 
import React, { useRef, useState } from 'react';
import { Line } from 'react-chartjs-2';
import {
  Dimensions,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native'; // React Native UI Components

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

export const sensorStartTimesRef = useRef<number[]>(Array(15).fill(0));
export const rawStartTimesRef = useRef<number[]>(Array(15).fill(0));

// Constants
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;   // Retrieves device dimensions for chart sizing
const chartHeight = screenHeight / 3.5;
const NUM_COLUMNS = 35; // 35 data channels 7 per satellite 5 satellites each channel has 170 samples
const DATA_LENGTH = 170;

// Sampling Frequencies (Hz)
const SamplingFreqGyro = 2730.66;
const SamplingFreqImpact = 5461.33;
const SamplingFreqAccelero = 5120;

// Chart Dimensions
const GyroDimensions = 2000 ;
const AcceleroDimensions = 4000 ;
const ImpactDimensions = 2.4 ;

const staticColors = [
  '#28a745', '#007bff', '#ffc107', '#dc3545',
  '#17a2b8', '#6f42c1', '#fd7e14',
];

// array column identifiers
const labelMap: { [key: string]: string } = {
  col0:  'Gyro X', col1:  'Gyro Y', col2:  'Gyro Z', col3:  'Accel X', col4:  'Accel Y', col5:  'Accel Z', col6:  'Impact',
  col7:  'Gyro X', col8:  'Gyro Y', col9:  'Gyro Z', col10: 'Accel X', col11: 'Accel Y', col12: 'Accel Z', col13: 'Impact',
  col14: 'Gyro X', col15: 'Gyro Y', col16: 'Gyro Z', col17: 'Accel X', col18: 'Accel Y', col19: 'Accel Z', col20: 'Impact',
  col21: 'Gyro X', col22: 'Gyro Y', col23: 'Gyro Z', col24: 'Accel X', col25: 'Accel Y', col26: 'Accel Z', col27: 'Impact',
  col28: 'Gyro X', col29: 'Gyro Y', col30: 'Gyro Z', col31: 'Accel X', col32: 'Accel Y', col33: 'Accel Z', col34: 'Impact',
};

const ChartBlock = ({
  title, series, yAxisMin, yAxisMax, yAxisTitle, compact = false, startTimeOffset = 0,
}: {
  title: string;
  series: { label: string; data: number[] }[];
  yAxisMin: number;
  yAxisMax: number;
  yAxisTitle: string;
  compact?: boolean;
  startTimeOffset?: number;
}) => {
  const sampleFreq =   // creates the charts X axis values (ms) based on the chart title and associated sampling freq
    title === 'Gyroscope' ? SamplingFreqGyro :
    title === 'Accelerometer' ? SamplingFreqAccelero :  
    SamplingFreqImpact;

   const timeLabels = series[0]?.data.map((_, idx) =>                       // uncomment these two lines for shifting the plots
   `${((idx * (1000 / sampleFreq)) + startTimeOffset).toFixed(1)}`          // uncomment these two lines for shifting the plots
   // const timeLabels = series[0]?.data.map((_, idx) =>                          // uncomment these two lines for not shifting the plots
   // `${(idx * (1000 / sampleFreq)).toFixed(1)}`                                 // uncomment these two lines for not shifting the plots
);

  const chartData = { // Maps input series to Chart.js datasets.
    labels: timeLabels,
    datasets: series.map((s, i) => ({
      label: labelMap[s.label] || s.label, // using label map converts keys (col0, col1 etc) into associated labels)
      data: s.data,
      borderColor: staticColors[i % staticColors.length],
      backgroundColor: staticColors[i % staticColors.length],
      fill: false,
      pointRadius: 0,
      tension: 0.4,
    })),
  };

  const options = { // configures both axis, x in (ms) y axis as a prop, also configures grid lines and legend
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: {
          display: !compact,
          text: 'Time (ms)',
       //   color: '#fff',
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          display: true,
          font: { size: compact ? 8 : 12, weight: 'bold' },
          maxTicksLimit: 10,
        },
        grid: {
          display: true,
          color: '#e0e0e0',
          lineWidth: 1,
        },
      },
      y: {
        title: {
          display: !compact,
          text: yAxisTitle,
          font: { size: 14, weight: 'bold' },
        },
        ticks: {
          font: { size: compact ? 8 : 12, weight: 'bold' },
        },
        min: yAxisMin,
        max: yAxisMax,
        grid: {
          color: (ctx: any) => (ctx.tick.value === 0 ? '#000' : '#ccc'),
          lineWidth: (ctx: any) => (ctx.tick.value === 0 ? 2 : 1),
        },
      },
    },
    plugins: {
      legend: {
        labels: {
          boxWidth: 10,
          boxHeight: 6,
          usePointStyle: true,
          pointStyle: 'rect',
          font: { weight: 'bold', size: compact ? 10 : 12 },
          color: '#333',
        },
      },
    },
  };

  return (
    <View style={[styles.chartBlock, compact && styles.compactChart]}>
      <Text style={[styles.subtitle, compact && styles.compactSubtitle]}>{title}</Text>
      <Line
        data={chartData}
        options={options}
        width={compact ? screenWidth / 3.6 : screenWidth / 2 - 30} // width and height calculations just work im not sure - 
        height={compact ? chartHeight / 2.2 : chartHeight}         // why the numbers work as they are 
      />
    </View>
  );
};


const SensorTab = ({ startIndex, sensorData }: { startIndex: number; sensorData: { [key: string]: number[] } }) => {
  const satIndex = startIndex / 7;
  const gyroOffset = sensorStartTimesRef.current[satIndex * 3 + 0] || 0;
  const accelOffset = sensorStartTimesRef.current[satIndex * 3 + 1] || 0;
  const impactOffset = sensorStartTimesRef.current[satIndex * 3 + 2] || 0;
  
  const getSeries = (keys: string[]) =>
    keys.map((key) => ({
      label: key,
      data: sensorData[key] || [],
    }));
    

  const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);


  ///////////// How "series" works  //////////////////////////////////////////////////////
  // Let’s say you are rendering an Accelerometer chart for Satellite 1.
  //                    const keys = Array.from({ length: 7 }, (_, i) => `col${startIndex + i}`);
  // we would get this ['col0', 'col1', 'col2', 'col3', 'col4', 'col5', 'col6']
  // then for the accelerometer series={getSeries(keys.slice(3, 6))}  // ['col3', 'col4', 'col5']
  // this becomes       series = [
  //                      { label: 'col3', data: sensorData['col3'] },
  //                      { label: 'col4', data: sensorData['col4'] },
  //                      { label: 'col5', data: sensorData['col5'] },
  //                    ];
  // Each entry in series then becomes a separate line on the chart.                    
  //                      datasets: series.map((s, i) => ({
  //                      label: labelMap[s.label] || s.label,  // Converts col3 -> "Accel X"
  //                      data: s.data,                         // 170 samples
  //                      ...
  //                    }))
  // How it configures for all 5 charts //
  // Each SensorTab is passed a startIndex, which is:
  //                    <SensorTab startIndex={14} sensorData={sensorData} />  // Satellite 3
  //                    startIndex = 7 * satelliteIndex
  // This offset tells the tab which set of 7 columns (out of 35) to use for that satellite.
  //
  //
  /////////////////////////////////////////////////////////////////////////////////////

  return (
    <View style={styles.fixedContainer}>
      <Text style={styles.title}>Sensor Dashboard</Text>
      <View style={styles.topRow}>
        <ChartBlock
          title="Accelerometer"
          series={getSeries(keys.slice(3, 6))}
          yAxisMin={-AcceleroDimensions}
          yAxisMax={AcceleroDimensions}
          yAxisTitle="Acceleration (g)"
          startTimeOffset={accelOffset}
        />
        <ChartBlock
          title="Gyroscope"
          series={getSeries(keys.slice(0, 3))}
          yAxisMin={-GyroDimensions}
          yAxisMax={GyroDimensions}
          yAxisTitle="Angular Velocity (°/s)"
          startTimeOffset={gyroOffset}
        />
        <ChartBlock
          title="Impact"
          series={getSeries([keys[6]])}
          yAxisMin={0}
          yAxisMax={ImpactDimensions}
          yAxisTitle="Impact (V)"
          startTimeOffset={impactOffset}
        />

      </View>
    </View>
  );
};

const AllSatellitesTab = ({ sensorData }: { sensorData: { [key: string]: number[] } }) => {
  const chartTypes = ['Accelerometer', 'Gyroscope', 'Impact'];
  const chartSettings = {
    Accelerometer: { yMin: -AcceleroDimensions, yMax: AcceleroDimensions, yLabel: 'Acceleration (g)' },
    Gyroscope: { yMin: -GyroDimensions, yMax: GyroDimensions, yLabel: 'Angular Velocity (°/s)' },
    Impact: { yMin: 0, yMax: ImpactDimensions, yLabel: 'Impact (V)' },
  };

  const chartBlocks: JSX.Element[] = [];

  for (let i = 0; i < 5; i++) {
    const startIndex = i * 7;
    const keys = Array.from({ length: 7 }, (_, j) => `col${startIndex + j}`);
    const getSeries = (indices: number[]) =>
      indices.map((j) => ({
        label: keys[j],
        data: sensorData[keys[j]] || [],
      }));

    const baseIdx = i * 3;
    const gyroOffset = sensorStartTimesRef.current[baseIdx + 0] || 0;
    const accelOffset = sensorStartTimesRef.current[baseIdx + 1] || 0;
    const impactOffset = sensorStartTimesRef.current[baseIdx + 2] || 0;

    chartTypes.forEach((type) => {
      const { yMin, yMax, yLabel } = chartSettings[type as keyof typeof chartSettings];
      const indices = type === 'Impact' ? [6] : type === 'Gyroscope' ? [0, 1, 2] : [3, 4, 5];
      const offset = type === 'Impact' ? impactOffset : type === 'Gyroscope' ? gyroOffset : accelOffset;
    
      chartBlocks.push(
        <ChartBlock
          key={`${type}-${i}`}
          title={type}
          series={getSeries(indices)}
          yAxisMin={yMin}
          yAxisMax={yMax}
          yAxisTitle={yLabel}
          compact={true}
          startTimeOffset={offset}
        />
      );
    });

  }

  return <View style={styles.allSatellitesGrid}>{chartBlocks}</View>;
};

const Tab = createBottomTabNavigator();

export default function App() {
  const [sensorData, setSensorData] = useState<{ [key: string]: number[] }>(() => {     // initialies the array 35 columns 170 rows 
    const data: { [key: string]: number[] } = {};
    for (let i = 0; i < NUM_COLUMNS; i++) {
      data[`col${i}`] = Array(DATA_LENGTH).fill(0);                                     // initiallizes all values to 0
    }
    return data;
  });

  //      // TEMPORARY: Hardcoded start times for testing x-axis offsets
  //      useEffect(() => {
  //        const dummyOffsets = [
  //          0, 1, 2,    // Satellite 1: Gyro, Accel, Impact
  //          3, 4, 5,   // Satellite 2
  //          6, 7, 8,   // Satellite 3
  //          9, 10, 11, // Satellite 4
  //          12, 13, 14 // Satellite 5
  //        ];
  //        sensorStartTimesRef.current = dummyOffsets;
  //        console.log('Hardcoded sensor start times applied:', sensorStartTimesRef.current);
  //      }, []);


  const handleLiveSensorUpdate = (newValues: { [key: string]: number[] }) => {
    setSensorData(newValues);
  };

  return (
    <>
      <Tab.Navigator sceneContainerStyle={{ backgroundColor: '#fff' }}>
        <Tab.Screen name="Satellite Board 1">
          {() => <SensorTab startIndex={0} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 2">
          {() => <SensorTab startIndex={7} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 3">
          {() => <SensorTab startIndex={14} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 4">
          {() => <SensorTab startIndex={21} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="Satellite Board 5">
          {() => <SensorTab startIndex={28} sensorData={sensorData} />}
        </Tab.Screen>
        <Tab.Screen name="All Satellites">
          {() => <AllSatellitesTab sensorData={sensorData} />}
        </Tab.Screen>
      </Tab.Navigator>

      <BLEConnector onSensorData={handleLiveSensorUpdate} />
    </>
  );
}

const styles = StyleSheet.create({
  fixedContainer: {
    flex: 1,
    backgroundColor: '#fff',
    paddingTop: 10,
    paddingHorizontal: 10,
    justifyContent: 'space-around',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexWrap: 'wrap',
  },
  bottomRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 5,
  },
  chartBlock: {
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  compactChart: {
    width: screenWidth / 3.6,
    height: chartHeight / 2.2,
    margin: 2,
  },
  subtitle: {
    fontSize: 16,
    marginBottom: 5,
    color: '#333',
    fontWeight: 'bold',
  },
  compactSubtitle: {
    fontSize: 10,
    marginBottom: 1,
  },
  allSatellitesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 4,
  },
  bleBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#ccc',
  },
  bleText: {
    fontSize: 12,
    color: '#333',
  },
  bleButton: {
    backgroundColor: '#007bff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  bleButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});


//////////////////////////////////////////////////////
//                    BLE CONNECTOR
//////////////////////////////////////////////////////


const BLEConnector = ({ onSensorData }: { onSensorData: (data: { [key: string]: number[] }) => void }) => {
  
  const [status, setStatus] = useState('Disconnected');
  const [connected, setConnected] = useState(false);
  const sensorMatrixRef = useRef<number[][]>(
    Array.from({ length: 170 }, () => Array(35).fill(null))
  );
  

  const incompleteChunksRef = useRef<{ [uuid: string]: number[] }>({});

  const deviceName = 'Real Data';
  const userServiceUUID = '152f2e2d-2c2b-2a29-2827-262524232221';
  const gyroscopeUUID = '100f0e0d-0c0b-0a09-0807-060504030201';
  const accelerometerUUID = '201f1e1d-1c1b-1a19-1817-161514131211';
  const impactsensorUUID = '302f2e2d-2c2b-2a29-2827-262524232221';

  let accCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let gyroCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let impactCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];
  let userDataCharacteristics: BluetoothRemoteGATTCharacteristic[] = [];

  // const sensorStartTimesRef = useRef<number[]>(Array(15).fill(null)); // start time array 15 vales 3 sensors x5 satellites


    //   sensorStartTimesRef.current = [      
    //   Gyro1, Accel1, Impact1,   // indexes 0–2     
    //   Gyro2, Accel2, Impact2,   // 3–5           This is how the code will store the times
    //   Gyro3, Accel3, Impact3,   // 6–8           This is how the code will store the times
    //   Gyro4, Accel4, Impact4,   // 9–11      
    //   Gyro5, Accel5, Impact5    // 12–14     
    // ]      


  const connectToDevice = async () => {
    try {
      setStatus('Requesting BLE device...');
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ name: deviceName }],
        optionalServices: [userServiceUUID, accelerometerUUID, gyroscopeUUID, impactsensorUUID],
      });

      const server = await device.gatt!.connect();
      setStatus(`Connected to ${device.name}`);
      setConnected(true);

      const impactService = await server.getPrimaryService(impactsensorUUID);
      impactCharacteristics = await impactService.getCharacteristics();

      const accService = await server.getPrimaryService(accelerometerUUID);
      accCharacteristics = await accService.getCharacteristics();

      const gyroService = await server.getPrimaryService(gyroscopeUUID);
      gyroCharacteristics = await gyroService.getCharacteristics();

      const userService = await server.getPrimaryService(userServiceUUID);
      userDataCharacteristics = await userService.getCharacteristics();

      subscribeToAllNotifications();
    } catch (err) {
      console.error('BLE connection failed:', err);
      setStatus('BLE connection failed.');
    }
  };

  const subscribeToAllNotifications = () => {
    const allCharacteristics = [
      ...accCharacteristics,
      ...gyroCharacteristics,
      ...impactCharacteristics,
      ...userDataCharacteristics,
    ];

    allCharacteristics.forEach((char) => {
      char.startNotifications().then(() => {
        char.addEventListener('characteristicvaluechanged', (event) =>
          handleCharacteristicNotification(event.target as BluetoothRemoteGATTCharacteristic)
        );
        console.log(`Notifications started for ${char.uuid}`);
      }).catch((e) => console.log('Notification error:', e));
    });
  };

  const handleCharacteristicNotification = (characteristic: BluetoothRemoteGATTCharacteristic) => {
    const uuid = characteristic.uuid;
    const value = characteristic.value!;
    const chunk = new Uint8Array(value.buffer);

    if (!incompleteChunksRef.current[uuid]) {
      incompleteChunksRef.current[uuid] = [];
    }
    incompleteChunksRef.current[uuid].push(...chunk);

    const len = incompleteChunksRef.current[uuid].length;
    
    const NormalizeBySensorType = () => {
      const groups = {
        gyro:   [0, 3, 6, 9, 12],
        accel:  [1, 4, 7, 10, 13],
        impact: [2, 5, 8, 11, 14],
      };
    
      Object.values(groups).forEach(indices => {
        const allPresent = indices.every(i => sensorStartTimesRef.current[i] > 0);
        const alreadyNormalized = indices.every(i => sensorStartTimesRef.current[i] < 10000); // <10s
      
        if (allPresent && !alreadyNormalized) {
          const minStart = Math.min(...indices.map(i => sensorStartTimesRef.current[i]));
          indices.forEach(i => {
            sensorStartTimesRef.current[i] -= minStart;
          });
        
          const labelPrefix =
            indices === groups.gyro ? 'Gyro' :
            indices === groups.accel ? 'Accel' : 'Impact';
        
          console.log(`✅ Normalized ${labelPrefix} start times:`);
          indices.forEach((i, idx) => {
            console.log(`${labelPrefix}${idx + 1}: ${sensorStartTimesRef.current[i]} ms`);
          });
        }
      });
    };

    // const NormalizeBySensorType = () => {   /// OLD METHOD FOR START TIMES NO RAW DATA PROTECTIONS
    //     const groups = {
    //       gyro:   [0, 3, 6, 9, 12],
    //       accel:  [1, 4, 7, 10, 13],
    //       impact: [2, 5, 8, 11, 14],
    //     };
    //   
    //     Object.values(groups).forEach(indices => {
    //       if (indices.every(i => sensorStartTimesRef.current[i] > 0)) {
    //         const minStart = Math.min(...indices.map(i => sensorStartTimesRef.current[i]));
    //         indices.forEach(i => {
    //           sensorStartTimesRef.current[i] -= minStart;
    //         });
    //       
    //         const labelPrefix = indices === groups.gyro
    //           ? 'Gyro' : indices === groups.accel
    //           ? 'Accel' : 'Impact';
    //       
    //         console.log(`✅ Normalized ${labelPrefix} start times:`);
    //         indices.forEach((i, idx) => {
    //           console.log(`${labelPrefix}${idx + 1}: ${sensorStartTimesRef.current[i]} ms`);
    //         });
    //       }
    //     });
    //   };

    const finalizeAndStore = (bufferSize: number, axisOffset: number, startIdx: number) => {
      const completeBuffer = new Uint8Array(incompleteChunksRef.current[uuid].slice(0, bufferSize));
      incompleteChunksRef.current[uuid] = [];

      const view = new DataView(completeBuffer.buffer);
      const eventId = view.getUint16(0, true);
      const satelliteId = view.getUint8(2);
      const axisType = view.getUint8(3);
      // const startTime = view.getUint32(4);
      const samples: number[] = [];
      // const impactTimes: number[] = [];
      // const gyroTimes: number[] = [];
      // const acceleroTimes: number[] = [];
      



      const satOffset = (satelliteId - 1) * 7;
      let columnIndex: number | null = null;
      let multipler =0;
   

      // test
      const startTime = view.getUint32(4, true); // grab the sensor's start time
      const baseIndex = (satelliteId - 1) * 3;

      if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('🟢 Gyro');
      
        columnIndex = satOffset + axisType;
        if (sensorStartTimesRef.current[baseIndex + 0] === 0) {
          rawStartTimesRef.current[baseIndex + 0] = startTime;
          sensorStartTimesRef.current[baseIndex + 0] = startTime;
          console.log(`Gyro start time for Sat ${satelliteId}: ${startTime}`);
          NormalizeBySensorType();
        }
      
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false)); // big endian
        }
        multipler = 1 / 16.4;
      }
      
      else if (accCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('🔵 Accel');
      
        columnIndex = satOffset + 3 + axisType;
        if (sensorStartTimesRef.current[baseIndex + 1] === 0) {
          rawStartTimesRef.current[baseIndex + 1] = startTime;
          sensorStartTimesRef.current[baseIndex + 1] = startTime;
          console.log(`Accel start time for Sat ${satelliteId}: ${startTime}`);
          NormalizeBySensorType();
        }
      
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, true)); // little endian
        }
        multipler = 0.2;
      }
      
      else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
        console.log('🔴 Impact');
      
        columnIndex = satOffset + 6;
        if (sensorStartTimesRef.current[baseIndex + 2] === 0) {
          rawStartTimesRef.current[baseIndex + 2] = startTime;
          sensorStartTimesRef.current[baseIndex + 2] = startTime;
          console.log(`Impact start time for Sat ${satelliteId}: ${startTime}`);
          NormalizeBySensorType();
        }
      
        for (let i = startIdx; i < view.byteLength; i += 2) {
          samples.push(view.getInt16(i, false)); // big endian
        }
        multipler = 2.42 / 4095;
      }
      // new start time logic 
      

      // new start time logic

      
      // Normalize start times once all 15 are populated
//    if (sensorStartTimesRef.current.every(t => t > 0)) {
//      const minStart = Math.min(...sensorStartTimesRef.current);
//      sensorStartTimesRef.current = sensorStartTimesRef.current.map(t => t - minStart);
//      console.log('✅ Normalized start times (in ms):', sensorStartTimesRef.current);
//    
//      // Optional labeled debug log for clarity
//      [
//        'Gyro1', 'Accel1', 'Impact1',
//        'Gyro2', 'Accel2', 'Impact2',
//        'Gyro3', 'Accel3', 'Impact3',
//        'Gyro4', 'Accel4', 'Impact4',
//        'Gyro5', 'Accel5', 'Impact5'
//      ].forEach((label, i) => {
//        console.log(`${label}: ${sensorStartTimesRef.current[i]} ms`);
//      });
//    }

      // test
      //       if (gyroCharacteristics.some((c) => c.uuid === uuid)) {
      //         console.log('Gyro');
      //         columnIndex = satOffset + axisType;
      //         // gyroTimes.push(view.getUint32(4, false));
      //         // samples.map(x => x / 16.4)
      //         for (let i = startIdx; i < view.byteLength; i += 2) {
      //           samples.push(view.getInt16(i, false));
      //         }
      //         
      //         //  for (let i = 4; i < 16; i += 4) {
      //         //    gyroTimes.push(view.getUint32(i, false));
      //         //  }
//       
      //         console.log(gyroTimes);
      //         multipler = 1/16.4;
      //       } else if (accCharacteristics.some((c) => c.uuid === uuid)) {
      //         console.log('Acc');
      //         columnIndex = satOffset + 3 + axisType;
      //         // acceleroTimes.push(view.getUint32(4, false));
      //         multipler = 0.2;
      //         for (let i = startIdx; i < view.byteLength; i += 2) {
      //           samples.push(view.getInt16(i, true));
      //         }
//       
      //       } else if (impactCharacteristics.some((c) => c.uuid === uuid)) {
      //         console.log('Impact');
      //         columnIndex = satOffset + 6;
      //         // impactTimes.push(view.getUint32(4, false));
      //         // samples.map(x => x *(2.42/4095))
      //         multipler = (2.42/4095);
      //         for (let i = startIdx; i < view.byteLength; i += 2) {
      //           samples.push(view.getInt16(i, false));
      //         }
      //       }

      if (columnIndex !== null) {
        for (let i = 0; i < samples.length && i < 170; i++) {
          console.log(samples);
          sensorMatrixRef.current[i][columnIndex] = samples[i]*multipler;
        }

        console.log(`Stored data → Satellite ${satelliteId}, Col ${columnIndex}, Samples: ${samples.length}`);

        // Push update to parent chart
        const newData: { [key: string]: number[] } = {};
        for (let col = 0; col < 35; col++) {
          newData[`col${col}`] = sensorMatrixRef.current.map((row) => row[col] ?? 0);
        }
        onSensorData(newData);
      }
    };

    if (len >= 354) {
      finalizeAndStore(354, 0, 14);
    } else if (len === 353) {
      finalizeAndStore(353, 0, 13);
    }
  };

const downloadCSV = async (sensorMatrix: number[][]) => {
  if (!Array.isArray(sensorMatrix) || !Array.isArray(sensorMatrix[0])) {
    alert('No data to export!');
    return;
  }
 const rows = sensorMatrix.map((row, i) => {
  const rowValues = row.map(val => (val !== null ? val.toFixed(4) : '0'));
  return rowValues.join(',');

  // const rowValues = row.map(val => (val !== null ? val.toFixed(4) : '0'));
// 
  // const raw = i < 15 ? rawStartTimesRef.current[i].toString() : '';
  // const normalized = i < 15 ? sensorStartTimesRef.current[i].toString() : '';
// 
  // return [...rowValues, raw, normalized].join(',');
});

// === Headers: Descriptive labels for each column ===
const sensorLabels = [
  'Gyro X', 'Gyro Y', 'Gyro Z',
  'Accel X', 'Accel Y', 'Accel Z',
  'Impact'
];

const headers = Array.from({ length: 35 }, (_, i) => {
  const sensorIdx = i % 7;
  const satNum = Math.floor(i / 7) + 1;
  return `${sensorLabels[sensorIdx]} ${satNum}`;
}).concat('RawStartTime', 'NormalizedStartTime');

rows.unshift(headers.join(','));

const csvContent = rows.join('\n');

  const now = new Date();
  const defaultName = `SensorData_${now.toISOString().slice(0,19).replace(/:/g,"-")}.csv`;

  // Check if File System Access API is available
  if ('showSaveFilePicker' in window) {
    try {
      // @ts-ignore
      const handle = await window.showSaveFilePicker({
        suggestedName: defaultName,
        types: [
          {
            description: 'CSV Files',
            accept: { 'text/csv': ['.csv'] },
          },
        ],
      });
      const writable = await handle.createWritable();
      await writable.write(csvContent);
      await writable.close();
      alert('File saved successfully!');
    } catch (e) {
      // if (e.name !== 'AbortError') alert('Could not save file: ' + e.message); // add back if you want the catch 
    }
  } else {
    // Fallback for unsupported browsers: trigger download as before
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = defaultName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

const loadCSVAndPlot = async () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.csv';
  input.onchange = async (e: any) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    const lines = text.trim().split('\n');

    if (lines.length < 2) {
      alert("CSV file is empty or invalid.");
      return;
    }

    // Skip header and parse data rows
    const dataLines = lines.slice(1);

    const matrix: number[][] = dataLines.map(line =>
      line.split(',').map(x => parseFloat(x))
    );

    // === Rebuild sensorData from columns 0–34
    const newData: { [key: string]: number[] } = {};
    for (let col = 0; col < 35; col++) {
      newData[`col${col}`] = matrix.map(row => row[col] ?? 0);
    }

    // === Restore raw and normalized start times (columns 35, 36) from first 15 rows
for (let i = 0; i < 15; i++) {
  const row = matrix[i];
  const raw = row[35];
  const normalized = row[36];

  if (!isNaN(raw)) rawStartTimesRef.current[i] = raw;
  if (!isNaN(normalized)) sensorStartTimesRef.current[i] = normalized;

  // 💡 Write values back into the matrix so they show up again in download
  sensorMatrixRef.current[i][35] = rawStartTimesRef.current[i];
  sensorMatrixRef.current[i][36] = sensorStartTimesRef.current[i];
}


    // Update sensorMatrixRef.current so downloadCSV gets real data
  for (let row = 0; row < 170; row++) {
    for (let col = 0; col < 35; col++) {
      sensorMatrixRef.current[row][col] = matrix[row]?.[col] ?? 0;
    }
  }

    onSensorData(newData);
  };

  input.click();
};

  return (
    <View style={[styles.bleBar, { flexDirection: 'column', alignItems: 'center' }]}>
  <Text style={styles.bleText}>{status}</Text>
  <View style={{ flexDirection: 'row', gap: 10, marginVertical: 4 }}>
    <TouchableOpacity
      onPress={connectToDevice}
      disabled={connected}
      style={[styles.bleButton, connected && { backgroundColor: 'gray' }]}
    >
      <Text style={styles.bleButtonText}>{connected ? 'Connected' : 'Connect'}</Text>
    </TouchableOpacity>
          <TouchableOpacity
        onPress={() => downloadCSV(sensorMatrixRef.current)}
        style={styles.bleButton}
      >
        <Text style={styles.bleButtonText}>Download to CSV</Text>
      </TouchableOpacity>
    <TouchableOpacity
      onPress={loadCSVAndPlot}
      style={styles.bleButton}
    >
      <Text style={styles.bleButtonText}>Upload Data</Text>
    </TouchableOpacity>
  </View>
</View>
  );
  
};


